<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qidianxuan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qidianxuan.github.io/"/>
  <updated>2019-12-28T12:12:11.516Z</updated>
  <id>http://qidianxuan.github.io/</id>
  
  <author>
    <name>qidianxuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaEE复习-架构</title>
    <link href="http://qidianxuan.github.io/2019/12/28/JavaEE%E5%A4%8D%E4%B9%A0-%E6%9E%B6%E6%9E%84/"/>
    <id>http://qidianxuan.github.io/2019/12/28/JavaEE%E5%A4%8D%E4%B9%A0-%E6%9E%B6%E6%9E%84/</id>
    <published>2019-12-28T10:35:41.000Z</published>
    <updated>2019-12-28T12:12:11.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><p>MVC全名是Model View Controller, 即”模型-视图-控制器”, 的缩写,用业务逻辑, 数据, 界面显示分离的方法组织代码. 其中:</p><ul><li>模型: 企业数据即业务规划.</li><li>视图: 用户看到并与之交互的界面</li><li>控制器: 接受用户的输入并调用模型和视图完成用户的需求</li></ul><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean是一种特殊的Java类, 与其他类不同的是它具有:</p><a id="more"></a><ul><li>一个无参的构造函数</li><li>需要被序列化, 即实现Serializable接口</li><li>对于对象的属性, 需要设置一系列setter()函数与getter()函数来保证可访问</li></ul><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Model1"><a href="#Model1" class="headerlink" title="Model1"></a>Model1</h3><p>Model1的思想为JSP页面与JavaBean结合, 如图示:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Je-Model1.png" alt><br>设计相对简单但是对于JSP任务过于繁杂</p><h3 id="Model2"><a href="#Model2" class="headerlink" title="Model2"></a>Model2</h3><p>Model2基于MVC模式, 如图示:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/je-Model2.png" alt><br>设计对小软件较复杂但分工明确合理</p><h2 id="Strus1"><a href="#Strus1" class="headerlink" title="Strus1"></a>Strus1</h2><p>Struts是Apache软件基金会赞助的一个开源项目. 它通过采用Java Servlet/JSP技术, 实现了基于Java EE Web应用的MVC设计模式的应用框架, 是MVC经典设计模式中的一个经典产品.</p><h3 id="Strus1-1中的MVC实现设计"><a href="#Strus1-1中的MVC实现设计" class="headerlink" title="Strus1.1中的MVC实现设计:"></a>Strus1.1中的MVC实现设计:</h3><p><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/je-struts1.png" alt></p><h4 id="ActionServlet"><a href="#ActionServlet" class="headerlink" title="ActionServlet"></a>ActionServlet</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s<span class="tag">&lt;/<span class="name">servlet-namwe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>          </span><br><span class="line">        org.apache.struts.action.ActionServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ServletConfig--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/struts-config.xml<span class="tag">&lt;/<span class="name">param-vlaue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> s <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span> *.do <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ActionServlet捕获到用户请求后, 将创建响应的ActionFrom并初始化<br>注意到url-pattern为.do形式, 约定俗成的称呼</p><h4 id="ActionForm"><a href="#ActionForm" class="headerlink" title="ActionForm"></a>ActionForm</h4><ol><li>ActionForm类属性需要和JSP表单域相同, 即类中属性为参数, 并存在相应的setter和getter方法, 并要继承ActionForm类</li><li>在struts-config.xml定义</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form-beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form-bean</span> <span class="attr">name</span>=<span class="string">"xxForm"</span> <span class="attr">type</span>=<span class="string">"xxFrom"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form-beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><ol><li>Action类必须实现execute方法, Action类的作用为从ActionForm中解析参数, 如下例:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxAction</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionForward <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActionMapping mapping, </span></span></span><br><span class="line"><span class="function"><span class="params">        ActionForm form, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">        xxForm xxform = (xxFrom) form;</span><br><span class="line">        String xxPar = xxform.getXxPar(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置Action, 有如下参数需要注意<ul><li>path: 将请求的.do去掉来匹配</li><li>name: 匹配的ActionForm名</li><li>type: 实现类</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action-mappings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">path</span>=<span class="string">"/xx"</span> <span class="attr">type</span>=<span class="string">"xx.Action"</span> <span class="attr">name</span>=<span class="string">"xxForm"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--局部Forward--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action-mappings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DispatchAction"><a href="#DispatchAction" class="headerlink" title="DispatchAction"></a>DispatchAction</h4><p>注意到每有一个Action就需要实现一个类并配置, 当Action较多时非常繁琐, 所以有了DispatchAction</p><ul><li>DispatchAction是一个抽象类, 无需重构execute方法, 但是需要写明自己的方法, 如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> myAction extends DispatchAction&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionForward <span class="title">myway</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActionMapping mapping, </span></span></span><br><span class="line"><span class="function"><span class="params">            ActionForm form, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">            )</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            </span><br><span class="line">            xxForm xxform = (xxFrom) form;</span><br><span class="line">            String xxPar = xxform.getXxPar(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionForward <span class="title">unspecified</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActionMapping mapping, </span></span></span><br><span class="line"><span class="function"><span class="params">        ActionForm form, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">        xxForm xxform = (xxFrom) form;</span><br><span class="line">        String xxPar = xxform.getXxPar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当请求时无此方法(上例myway), 将调用unspecified方法.<br>配置:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">path</span>=<span class="string">"/xxx"</span> <span class="attr">type</span>=<span class="string">"myAction"</span> <span class="attr">parameter</span>=<span class="string">"xx"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当parameter为myway时, 将执行myway方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVC架构&quot;&gt;&lt;a href=&quot;#MVC架构&quot; class=&quot;headerlink&quot; title=&quot;MVC架构&quot;&gt;&lt;/a&gt;MVC架构&lt;/h2&gt;&lt;p&gt;MVC全名是Model View Controller, 即”模型-视图-控制器”, 的缩写,用业务逻辑, 数据, 界面显示分离的方法组织代码. 其中:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;模型: 企业数据即业务规划.&lt;/li&gt;
&lt;li&gt;视图: 用户看到并与之交互的界面&lt;/li&gt;
&lt;li&gt;控制器: 接受用户的输入并调用模型和视图完成用户的需求&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;JavaBean&quot;&gt;&lt;a href=&quot;#JavaBean&quot; class=&quot;headerlink&quot; title=&quot;JavaBean&quot;&gt;&lt;/a&gt;JavaBean&lt;/h2&gt;&lt;p&gt;JavaBean是一种特殊的Java类, 与其他类不同的是它具有:&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://qidianxuan.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaEE复习-JSP</title>
    <link href="http://qidianxuan.github.io/2019/12/28/JavaEE%E5%A4%8D%E4%B9%A0-JSP/"/>
    <id>http://qidianxuan.github.io/2019/12/28/JavaEE%E5%A4%8D%E4%B9%A0-JSP/</id>
    <published>2019-12-28T06:43:35.000Z</published>
    <updated>2019-12-28T08:20:00.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h2><ul><li>JSP中可以包含一些Java代码, 方法如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> 代码 %&gt;</span></span><br></pre></td></tr></table></figure><ul><li>同样的, 也可以插入一些表达式, 它会被转化为String 来插入到表达式出现的地方, 方法如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%=</span> 表达式 %&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JSP存在一些<strong>指令</strong>, 来设置页面的一些属性, 格式如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> 指令 属性=<span class="string">"值"</span> %&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>对于属性, 有如下类型</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">page</td><td style="text-align:center">定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td style="text-align:center">include</td><td style="text-align:center">包含其他文件</td></tr><tr><td style="text-align:center">taglib</td><td style="text-align:center">引入标签库的定义，可以是自定义标签</td></tr></tbody></table></div><ul><li>JSP定义了一套<strong>行为</strong>, 来控制servlet引擎, 格式如下:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:行为</span> 属性=<span class="string">"值"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>存在如下行为:</p><div class="table-container"><table><thead><tr><th style="text-align:left">行为</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">include</td><td style="text-align:left">用于在当前页面中包含静态或动态资源</td></tr><tr><td style="text-align:left">useBean</td><td style="text-align:left">寻找和初始化一个JavaBean组件</td></tr><tr><td style="text-align:left">setProperty</td><td style="text-align:left">设置 JavaBean组件的值</td></tr><tr><td style="text-align:left">getProperty</td><td style="text-align:left">将 JavaBean组件的值插入到 output中</td></tr><tr><td style="text-align:left">forward</td><td style="text-align:left">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td style="text-align:left">plugin</td><td style="text-align:left">用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td style="text-align:left">element</td><td style="text-align:left">动态创建一个XML元素</td></tr><tr><td style="text-align:left">attribute</td><td style="text-align:left">定义动态创建的XML元素的属性</td></tr><tr><td style="text-align:left">body</td><td style="text-align:left">定义动态创建的XML元素的主体</td></tr><tr><td style="text-align:left">text</td><td style="text-align:left">用于封装模板数据</td></tr></tbody></table></div><ul><li>JSP页面在创建时, 存在一些已经创建好的变量:<ol><li>HttpServletRequest <strong>request</strong></li><li>HttpServletResponse <strong>response</strong></li><li>HttpSession <strong>session</strong></li><li>ServletConfig <strong>config</strong></li><li>ServletContext <strong>application</strong></li><li>JspWriter <strong>out</strong></li><li>PageContext <strong><em>pageContext</em></strong></li><li>page <strong>this</strong></li><li>Exception <strong>exception</strong></li></ol></li></ul><h2 id="PageContext"><a href="#PageContext" class="headerlink" title="PageContext"></a>PageContext</h2><ul><li>继承自JspContext, 是一个抽象类</li><li>PageContext实例提供对与JSP页面关联的所有名称空间的访问，提供对若干页面属性的访问.<ul><li>Object getAttribute(String name);<ul><li>取得page内的一个name属性的值</li></ul></li><li>Object getAttribute(String name, int scope);<ul><li>取得scope内的一个name属性的值</li></ul></li><li>void setAttribute(String name, Object value); <ul><li>设置page内的一个name属性的值</li></ul></li><li>void setAttribute(String name, Object value, int scope); <ul><li>设置scope内的一个name属性的值</li></ul></li><li>scope存在如下取值<ul><li>PAGE_SCOPE = 1;</li><li>REQUEST_SCOPE = 2;</li><li>SESSION_SCOPE = 3;</li><li>APPLICATION_SCOPE = 4;</li></ul></li></ul></li></ul><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul><li>在JSP中访问模型对象是通过EL表达式的语法来表达。</li><li>所有EL表达式的格式都是以“${}”表示。</li><li>${ userinfo}代表获取变量userinfo的值, 若为规定范围, 则查找顺序为:<ul><li>page→request→session→application</li></ul></li><li><p>存在两种运算符</p><ul><li>. </li><li>[] ,动态或含有特殊字符</li></ul></li><li><p>举例:</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">request.getAttribute</span>("<span class="attr">name</span>") %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line">$&#123;requestScope.name&#125;</span><br></pre></td></tr></table></figure><h2 id="TAG-和-SimpleTag"><a href="#TAG-和-SimpleTag" class="headerlink" title="TAG 和 SimpleTag"></a>TAG 和 SimpleTag</h2><p>对于html, 支持自定义标签, 该接口定义了Tag处理程序和JSP页面实现类之间的基本协议</p><ul><li>TAG的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">int doEndTag()</td><td style="text-align:left">标签域结束时</td></tr><tr><td style="text-align:left">int doStartTag()</td><td style="text-align:left">标签域开始时调用, 一般使用此</td></tr><tr><td style="text-align:left">Tag getParent()</td><td style="text-align:left">获取父标签</td></tr><tr><td style="text-align:left">void release()</td><td style="text-align:left">释放标签</td></tr><tr><td style="text-align:left">void setPageContext(PageContext pc)</td><td style="text-align:left">设置当前的PageContext</td></tr><tr><td style="text-align:left">void setParent(Tag t)</td><td style="text-align:left">设置父标签</td></tr></tbody></table></div><ul><li>Simple Tag的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">void doTag()</td><td style="text-align:left">调用标签时</td></tr><tr><td style="text-align:left">JspTag getParent()</td><td style="text-align:left">获取父标签</td></tr><tr><td style="text-align:left">void setJspBody(JspFragment jspBody)</td><td style="text-align:left">设置Jsp body</td></tr><tr><td style="text-align:left">void setJspContext(JspContext pc)</td><td style="text-align:left">设置当前的JspContext</td></tr><tr><td style="text-align:left">void setParent(Tag t)</td><td style="text-align:left">设置父标签</td></tr></tbody></table></div><ul><li>如何使用<br>  可参考:<a href="https://blog.csdn.net/yy339452689/article/details/78520692" target="_blank" rel="noopener">https://blog.csdn.net/yy339452689/article/details/78520692</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSP语法&quot;&gt;&lt;a href=&quot;#JSP语法&quot; class=&quot;headerlink&quot; title=&quot;JSP语法&quot;&gt;&lt;/a&gt;JSP语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JSP中可以包含一些Java代码, 方法如下&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%&lt;/span&gt; 代码 %&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;同样的, 也可以插入一些表达式, 它会被转化为String 来插入到表达式出现的地方, 方法如下&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%=&lt;/span&gt; 表达式 %&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;JSP存在一些&lt;strong&gt;指令&lt;/strong&gt;, 来设置页面的一些属性, 格式如下&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%@&lt;/span&gt; 指令 属性=&lt;span class=&quot;string&quot;&gt;&quot;值&quot;&lt;/span&gt; %&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://qidianxuan.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaEE复习-API简要整理</title>
    <link href="http://qidianxuan.github.io/2019/12/20/JavaEE%E5%A4%8D%E4%B9%A0-API/"/>
    <id>http://qidianxuan.github.io/2019/12/20/JavaEE%E5%A4%8D%E4%B9%A0-API/</id>
    <published>2019-12-20T09:56:39.000Z</published>
    <updated>2019-12-28T12:12:14.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>简单的, 在百度输入”HTTP协议”并进行搜索, 在上面的搜索栏将会出现如下内容</p><blockquote><p><a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=HTTP%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">https://www.baidu.com/s?ie=UTF-8&amp;wd=HTTP%E5%8D%8F%E8%AE%AE</a></p></blockquote><p>这便是URL(Uniform Resource Locater, 统一资源定位符), 在WWW上，每一信息资源都有统一的且在网上唯一的地址, 即URL<br>通常URL由三部分组成, 即<br>| 协议 | 主机 | 路径 |<br>而对于 “?” 之后的内容, 叫做<strong>查询字符串</strong>(QueryString), 以名值对的形式出现,以”&amp;”分割<br>则对于上述的链接, 可分为如下内容:</p><a id="more"></a><blockquote><p>协议: HTTPS<br>主机: www.baidu.com<br>路径: /s<br>查询字符串: ie,值为UTF-8; wd,值为HTTP%E5%8D%8F%E8%AE%AE, 即”协议”的UTF-8编码</p></blockquote><p>一般而言, 你所访问的网页由HTML 或jsp 完成, 仅提供前端的显示, 后端的处理, 即收到数据所做的操作, 就需要后端进行处理, 而处理的过程, 由JavaEE的各种技术来提供</p><h2 id="一个标准的Web应用构成"><a href="#一个标准的Web应用构成" class="headerlink" title="一个标准的Web应用构成"></a>一个标准的Web应用构成</h2><p>一般而言, 一个基于JavaEE的Web应用构成结构如下:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/iavaEE_2.png" alt></p><h2 id="什么是JavaEE"><a href="#什么是JavaEE" class="headerlink" title="什么是JavaEE?"></a>什么是JavaEE?</h2><p>Java EE, Java 平台企业版(Java Platform Enterprise Edition), 之前称为Java 2 Platform, Enterprise Edition (J2EE). 狭义的 Java EE 是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件，可以说是一个框架，也可以说是一种规范. JavaEE包含众多技术, 重要的有</p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>Java 数据库连接, (Java Database Connectivity, JDBC)是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口, 提供了诸如查询和更新数据库中数据的方法.</p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>Servlet(Server Applet), 是用 Java 编写的服务器端程序. 其主要功能在于交互式地浏览和修改数据, 生成动态 Web 内容.<br>狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。</p><h4 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h4><p>JSP（JavaServer Pages）是由 Sun 公司主导创建的一种动态网页技术标准. JSP 部署于网络服务器上, 可以响应客户端发送的请求, 并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页, 然后返回给请求者.  </p><p>当然还有众多主要技术, 不做详细介绍.</p><h3 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h3><ul><li>Servelt 是一个<strong>接口</strong>, 定义了所有servlet所需要实现的功能</li><li>Servlet作为一个网页的后台处理Java程序的实现方法, 来处理前台用户的操作</li><li>一些主要的方法:<ul><li>void destory()  <ul><li>告知Servlet<strong>容器</strong>中止服务</li></ul></li><li>ServletConfig getServletConfig()  <ul><li>获得用于初始化Servlet的一个ServletConfig实例</li><li>将可能抛出ServletException  </li></ul></li><li>String getServletInfo()  <ul><li>获取Servlet的信息, 如作者, 版本, 版权等</li></ul></li><li>void init(ServletConfig config)  <ul><li>由Servlet容器自动调用来初始化Servlet</li><li>将可能抛出ServletException </li></ul></li><li>void service(ServletRequest req, ServletResponse res) <ul><li>服务函数, 定义Servlet如何对请求做出相应</li><li>可能抛出ServletException和IOException</li></ul></li></ul></li></ul><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>用于Servlet初始化时传递参数的<strong>接口</strong><br>一般而言, 每个ServletConfig对应一个Servlet<br>方法: </p><ul><li>String getInitParameter(String name)<br>  返回此Servlet实例的名称, 考虑如下web.xml中的参数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ServletParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>val<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 getInitParameter(“ServletParam”)将返回val</p><ul><li>ServletContext getServletContext()<br>  返回正在执行的ServletContext的调用, 考虑如下web.xml</li><li>Enumeration<string> getInitParameterNames()<br>  返回Servlet初始化参数的名字</string></li><li>String getServletName()<br>  返回该Servlet实例的名字</li></ul><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>定义了一系列Servlet应该如何与其容器交流的方法的<strong>接口</strong><br>一般而言, 一个WebApp对应一个ServletContext<br>这里有个很好的<a href="https://www.cnblogs.com/baoendemao/p/3804756.html" target="_blank" rel="noopener">说明</a><br>几个比较重要的方法:</p><ul><li>String getContextPath()<ul><li>返回web应用的上下文路径, 若部署了应用app, 则返回”/app”</li></ul></li><li>ServletContext getContext(String uripath)<ul><li>uripath为在此web应用容器内另一个web应用的上下文理解</li></ul></li><li>Set/<string> getResourcePaths(String path)<ul><li>返回path下所有资源文件路径的集合</li></ul></string></li><li>URL getResources(String path)<ul><li>根据path返回URL</li></ul></li><li>InputStream getResourceAsStream(String path)<ul><li>根据path返回数据流</li></ul></li><li>String getRealPath(String path)<ul><li>根据虚拟路径返回真实路径  </li></ul></li><li><p>String getInitParameter(String name)</p><ul><li><p>同ServletConfig中的getInitParameter,但书写方式不同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>param<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>val<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><ul><li>一个抽象类(abstract class)用于创建一个用于Web的Http Servlet, 通常至少要重构一个方法(除service外, 因为service可分发给每种HTTP请求(doXXX)来处理), 实现了接口Serializable, <strong>Servlet</strong>, ServletConfig </li><li>多线程编程</li><li>比较重要的方法<ul><li>protected void doGet(HttpServletRequest req,HttpServletResponse resp)<ul><li>抛出ServletRequest, IOException</li><li>处理来自前台的GET请求(GET请求在URL可见)</li></ul></li><li>protected void doPost(HttpServletRequest req,HttpServletResponse resp)<ul><li>抛出ServletRequest, IOException</li><li>处理来自前台的GET请求(POST请求在URL不可见)</li></ul></li><li>protected void service(HttpServletRequest req, HttpServletResponse resp)<ul><li>处理HTTP请求</li><li>一般不需要重构</li></ul></li></ul></li><li>缺陷: GET和POST仅可以建立”短连接”, 即当访问本Web应用程序的其他页面时, 数据将不会存在.</li></ul><h3 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h3><p>接口, 用于实现Http的Servlet请求<br>比较重要的几个函数</p><ul><li>Object getAttribute(String name)<ul><li>获取名为name的参数</li></ul></li><li>String getParameter(String name)<ul><li>获取名为name的参数, 此可来自参数前台页面</li></ul></li><li>void setAttribute(String name, Object o)<ul><li>为此ServletRequest设置一个参数</li></ul></li><li>RequestDispatcher    getRequestDispatcher(String path)<ul><li>返回一个以path路径资源的请求调度</li></ul></li></ul><h4 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h4><p>接口, 对于每个服务器上的资源(Servlet, html文件或jsp文件)都有一个RequestDispatcher对象, 他主要用于包装Servlet, 但Servlet可以用它来包装任何资源</p><ul><li>void forward(ServletRequest request, ServletResponse response)<ul><li>用于从一个Servlet到另一个资源的转发请求</li></ul></li><li>void include(ServletRequest request, ServletResponse response)<ul><li>将response中的资源包含到RequestDispatcher</li></ul></li></ul><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>接口, 继承自ServletRequest<br>比较重要的几个函数</p><ul><li>String getContextPath()  <ul><li>返回该函数的上下文</li></ul></li><li>Cookie[] getCookies()<ul><li>返回该Servlet下的Cookies</li></ul></li><li>HttpSession getSession()<ul><li>返回所创建的会话(Session)</li></ul></li><li>void setCharacterEncoding(String encode)  <ul><li>设置编码方式(解决中文乱码)</li></ul></li><li>注: 若想实现页面转发, 一种方式为:  <ul><li>request.getRequestDispatcher(目的页面).forward(request,response)</li></ul></li></ul><h3 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h3><p>接口, 用于实现Http的Servlet相应<br>比较重要的几个函数:</p><ul><li>PrintWriter getWriter()<ul><li>返回一个PrintWriter, 可以通过此来输出页面</li></ul></li><li>void setCharacterEncoding(String charset)<ul><li>设置编码格式</li></ul></li></ul><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>接口, 继承自ServletResopnse<br>比较重要的几个函数</p><ul><li>void addCookie(Cookie cookie)<ul><li>添加一个Cookie</li></ul></li><li>void setHeader(String name,String value)<ul><li>设置一个相应头</li><li>例子: response.setHeader(“content-type”,”text/html;charset=UTF-8”);</li></ul></li><li>void setContextType(String type)<ul><li>设置上下文</li><li>例子: response.setContentType(“text/html;charset=UTF-8”);</li></ul></li><li>注意到, 上述例子皆为满足一个响应中显示中文的需求</li></ul><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><ul><li>一个<strong>接口</strong>, 提供了在当前<strong>Web应用程序</strong>中让多个页面来实现对用户的认证, 同时也可以储存来自用户的数据, 仅对应于一个Servlet Context</li><li>Session是服务器技术</li><li>一些常用方法<ul><li>void setAttribute(String name, Object value)  <ul><li>绑定一个object在此session, name为其标识</li></ul></li><li>Object getAttribute(String name)  <ul><li>根据name返回用上述方法绑定的value</li></ul></li><li>Emumeration<string> getAttributeNames()  <ul><li>返回绑定于此Session的所有name</li></ul></string></li><li>ServletContext getServletContext()  <ul><li>返回该session所在的ServletContext</li></ul></li><li>void removeAttribute(String name)<ul><li>根据name删除一个名值对</li></ul></li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>Cookie(Cookies)一种小型的文本文件(不超过4KB), 来使某些网站辨别用户身份, 进行Session追踪来存储在用户本地的经过加密的数据.</li><li>Cookie是客户端技术</li><li>每次访问同一页面时, 浏览器会将你的Cookies上传到服务器</li><li>pulic class Cookie extends Object implements Cloneable, Serializable</li><li>构造函数Cookie(String name, String value)<ul><li>以name+value来创建一个cookie</li><li>抛出<strong>IllegalArgumentException</strong></li></ul></li><li>一些常用方法<ul><li>public void setMaxAge(int expiry)<ul><li>设置Cookie存活时间,单位为秒</li></ul></li><li>public void setPath(String uri)<ul><li>设置一个可以让客户端返回Cookies的路径</li><li>对于一个Cookie, 只有其同级文件及子文件夹可访问</li><li>路径为URL地址中的路径</li></ul></li><li>public void setValue(String newValue)<ul><li>为该Cookie设置一个新值</li></ul></li><li>上述方法同样存在get方法, 无需叙述</li></ul></li></ul><h5 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构doGet方法来设置一个Cookies</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletPequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"val"</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">        cookie.setPath(request.getContextPath());</span><br><span class="line">        response.addCookie(cookie);<span class="comment">//关键语句</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 重构doGet方法来显示当前存在的Cookies</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletPequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">        PrintWriter pw = response.getWriter();</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span>(cookies!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie:cookies)&#123;</span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                String value = cookie.getValue();</span><br><span class="line">                out.write(name+<span class="string">":"</span>+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebServlet中的Annotation"><a href="#WebServlet中的Annotation" class="headerlink" title="WebServlet中的Annotation"></a>WebServlet中的Annotation</h4><p>存在如下元素(主要的):</p><ul><li>String description<ul><li>关于该Servlet的描述</li></ul></li><li>String displayName<ul><li>该Servlet的显示名字</li></ul></li><li>WebInitParam[] initParams<ul><li>Servlet初始化参数, WebInitParam为名值对</li></ul></li><li><p>String name</p><ul><li><p>Servlet的name, 可以在web.xml中设置, 如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以通过Annotation配置, 如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebSocket</span>(name = <span class="string">"loginServlet"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String[] urlPatterns</p><ul><li>相当于在web.xml里servlet-mapping中的url-pattern</li></ul></li><li>String[] value<ul><li>同上</li></ul></li></ul><h4 id="WebInitParam中的Annotation"><a href="#WebInitParam中的Annotation" class="headerlink" title="WebInitParam中的Annotation"></a>WebInitParam中的Annotation</h4><ul><li>String name<ul><li>初始化参数的名字</li></ul></li><li>String value<ul><li>初始化参数的值</li></ul></li></ul><h4 id="WebListener中的Annotation"><a href="#WebListener中的Annotation" class="headerlink" title="WebListener中的Annotation"></a>WebListener中的Annotation</h4><ul><li>String value<ul><li>设置值</li></ul></li></ul><h4 id="WebFilter中的Annotation"><a href="#WebFilter中的Annotation" class="headerlink" title="WebFilter中的Annotation"></a>WebFilter中的Annotation</h4><ul><li>String description<ul><li>关于该Filter的描述</li></ul></li><li>String displayName<ul><li>该Filter的显示名字</li></ul></li><li>WebInitParam[] initParams<ul><li>Filter的初始化参数, WebInitParam为名值对</li></ul></li><li>DispatcherType[] dispatcherTypes<ul><li>filter所应用的dispatcher类型</li></ul></li><li>String[] servletNames<ul><li>filter所应用到的Servlet名字</li></ul></li><li>String filterName<ul><li>filter的名字</li></ul></li><li>String[] urlPatterns<ul><li>filter所引用的URL</li></ul></li><li>String[] value<ul><li>filter所引用的URL</li></ul></li></ul><h3 id="Java-Web-Events-和-Listener"><a href="#Java-Web-Events-和-Listener" class="headerlink" title="Java Web Events 和 Listener"></a>Java Web Events 和 Listener</h3><h4 id="ServletContextEvent"><a href="#ServletContextEvent" class="headerlink" title="ServletContextEvent"></a>ServletContextEvent</h4><ul><li>父类为EventObject</li><li>事件类, 当一个Servlet的Context改变时发生</li><li>构造函数: ServletContextEvent(ServletContext source)</li><li>监听接口: <strong>ServletContextListener</strong><ul><li>void contextDestoryed(ServletContextEvent sce)<ul><li>ServletContext将要关闭时收到通知</li></ul></li><li>void contextInitialized(ServletContextEvent sce)<ul><li>Web应用程序初始化时收到通知</li></ul></li></ul></li></ul><h4 id="ServletContextAttributeEvent"><a href="#ServletContextAttributeEvent" class="headerlink" title="ServletContextAttributeEvent"></a>ServletContextAttributeEvent</h4><ul><li>父类为ServletContextEvent</li><li>事件类, 当一个ServletContext的属性改变时发生</li><li>构造函数: ServletContextAttributeEvent(ServletContext source, String name, Object value)<ul><li>name为属性(Attribute)名</li><li>value为属性值</li></ul></li><li>监听接口: <strong>ServletContextAttributeListener</strong><ul><li>void attributeAdded(ServletContextAttributeEvent event)<ul><li>当ServletContext添加新的属性时收到通知</li></ul></li><li>void attributeRemoved(ServletContextAttributeEvent event)<ul><li>当ServletContext移除一个属性时收到通知</li></ul></li><li>void attributeReplaced(ServletContextAttributeEvent event)<ul><li>官方API未说明, 当ServletContext的一个属性被替换时收到通知(猜测)</li></ul></li></ul></li></ul><h4 id="ServletRequestEvent"><a href="#ServletRequestEvent" class="headerlink" title="ServletRequestEvent"></a>ServletRequestEvent</h4><ul><li>父类为EventObject</li><li>事件类, 与ServletRequest的生命周期有关, 事件来源为ServletContext</li><li>构造函数: ServletRequestEvent(ServletContext sc, ServletRequest request)</li><li>监听接口: <strong>ServletRequestListener</strong><ul><li>void requestDestoryed(ServletRequestEvent sre)<ul><li>当一个ServletRequest将要被销毁时收到通知</li></ul></li><li>void requestInitialized(ServletRequestEvent sre)<ul><li>当一个ServletRequest将要被创建时收到通知</li></ul></li></ul></li></ul><h4 id="ServletRequestAttributeEvent"><a href="#ServletRequestAttributeEvent" class="headerlink" title="ServletRequestAttributeEvent"></a>ServletRequestAttributeEvent</h4><ul><li>父类为ServletRequestEvent</li><li>事件类, 当Servlet Request的某个属性发生改变时收到通知</li><li>构造函数: ServletRequestAttributeEvent(ServletContext sc, ServletRequest request, String name, Object value)</li><li>监听接口: <strong>ServletRequestAttributeListener</strong><ul><li>void attributeAdded(ServletRequestAttributeEvent srae)<ul><li>当ServletRequest添加一个新属性时收到通知</li></ul></li><li>void attributeRemoved(ServletRequestAttributeEvent srae)<ul><li>当ServletRequest移除一个属性时收到通知</li></ul></li><li>void attributeReplaced(ServletRequestAttributeEvent srae)<ul><li>当ServletRequest替换一个属性时收到通知</li></ul></li></ul></li></ul><h4 id="HttpSessionEvent"><a href="#HttpSessionEvent" class="headerlink" title="HttpSessionEvent"></a>HttpSessionEvent</h4><ul><li>父类为EventObject</li><li>事件类, 当session发生改变时发生</li><li>构造函数: HttpSessionEvent(HttpSession source)</li><li>监听接口: <strong>HttpSessionListener</strong><ul><li>void sessionCreated(HttpSessionEvent se)<ul><li>当session被创建时收到通知</li></ul></li><li>void sessionDestoryed(HttpSessionEvent se)<ul><li>当session将要被销毁时收到通知</li></ul></li></ul></li><li>监听接口: <strong>HttpSessionActivationListener</strong><ul><li>void sessionDidActivate(HttpSessionEvent se)<ul><li>session被激活时收到通知</li></ul></li><li>void sessionWillPassivate(HttpSessionEvent se)<ul><li>session将要冷却时收到通知</li></ul></li></ul></li></ul><h4 id="HttpSessionBindingEvent"><a href="#HttpSessionBindingEvent" class="headerlink" title="HttpSessionBindingEvent"></a>HttpSessionBindingEvent</h4><ul><li>父类为HttpSessionEvent</li><li>事件类, 当一个session绑定或解除绑定时, 此事件将发送给监听对象<ul><li>调用HttpSession.setAttribute绑定对象</li><li>调用HttpSession.removeAttribute取消绑定</li></ul></li><li>构造函数<ul><li>HttpSessionBindingEvent(HttpSession session, String name)</li><li>HttpSessionBindingEvent(HttpSession session, String name, Object value)</li></ul></li><li>监听接口: <strong>HttpSessionBindingListener</strong><ul><li>void valueBound(HttpSessionBindingEvent event)<ul><li>当有一个object绑定到session时收到通知</li></ul></li><li>void valueUnbound(HttpSessionBindingEvent event)<ul><li>当有一个object解绑session时收到通知</li></ul></li></ul></li><li>监听接口: <strong>HttpSessionAttributeListener</strong><ul><li>void attributeAdded(HttpSessionBindingEvent event)<ul><li>当session添加一个新属性时收到通知</li></ul></li><li>void attributeRemoved(HttpSessionBindingEvent event)<ul><li>当session移除一个属性时收到通知</li></ul></li><li>void attributeReplaced(HttpSessionBindingEvent event)<ul><li>当session替换一个属性时收到通知</li></ul></li></ul></li></ul><h5 id="Listener的使用-以一个简单的例子为例"><a href="#Listener的使用-以一个简单的例子为例" class="headerlink" title="Listener的使用, 以一个简单的例子为例:"></a>Listener的使用, 以一个简单的例子为例:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Session 被创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestoryed</span><span class="params">(HttpSessionEvent se)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Session 被销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后, 在web.xml中配置监听器<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>myListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><br>或者也可以使用注解, 在上述Java代码类声明前加入, 亦可实现配置的作用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter是一个接口，它对 对资源（Servlet或静态内容）的请求或对资源的响应或两者都执行过滤任务。<br>一些常见的使用Filter的例子</p><ul><li>Authentication Filter 认证过滤</li><li>Logging and Auditing Filters 日志与审核过滤</li><li>Image conversion Filters 图片转换过滤</li><li>Data Compression Filters 数据压缩过滤</li><li>Encryption Filters 加密过滤</li><li>Tokenizing Filters 标记化过滤</li><li>Filters that trigger resource access events 触发资源访问事件的过滤器</li><li>XSL/T Filters</li><li>Mime-type chain Filter</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h5><ul><li>void init(FilterConfig filterconfig)<ul><li>throws ServletException</li><li>通过filterconfig来初始化一个filter</li></ul></li><li>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)<ul><li>throws IOException, ServletException</li><li>逻辑结束后需要<ul><li>使用chain.doFilter()来传递给Filter链的下一个Filter</li><li>直接相应以阻止</li></ul></li></ul></li><li>void destory()<ul><li>销毁该Filetr()</li></ul></li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li>创建一个Filter类, 继承自Filter接口</li><li>在web.xml中配置Filter</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义filter拦截的地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--此处也可以为目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;简单的, 在百度输入”HTTP协议”并进行搜索, 在上面的搜索栏将会出现如下内容&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baidu.com/s?ie=UTF-8&amp;amp;wd=HTTP%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baidu.com/s?ie=UTF-8&amp;amp;wd=HTTP%E5%8D%8F%E8%AE%AE&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;这便是URL(Uniform Resource Locater, 统一资源定位符), 在WWW上，每一信息资源都有统一的且在网上唯一的地址, 即URL&lt;br&gt;通常URL由三部分组成, 即&lt;br&gt;| 协议 | 主机 | 路径 |&lt;br&gt;而对于 “?” 之后的内容, 叫做&lt;strong&gt;查询字符串&lt;/strong&gt;(QueryString), 以名值对的形式出现,以”&amp;amp;”分割&lt;br&gt;则对于上述的链接, 可分为如下内容:&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://qidianxuan.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-语义分析-语法制导的翻译</title>
    <link href="http://qidianxuan.github.io/2019/12/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/"/>
    <id>http://qidianxuan.github.io/2019/12/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</id>
    <published>2019-12-10T02:17:10.000Z</published>
    <updated>2019-12-10T03:03:48.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法制导"><a href="#语法制导" class="headerlink" title="语法制导"></a>语法制导</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>对应每一个产生式编制一个语义子程序, 当一个产生式获得匹配时, 调用相应的语义子程序实现语义检查与翻译</li><li>带属性和规则的上下文无关文法, 称之为<strong>基础文法</strong><h3 id="翻译方案"><a href="#翻译方案" class="headerlink" title="翻译方案"></a>翻译方案</h3>在产生式的右部的适当位置, 插入相应的语义动作, 按照分析的进程, 执行遇到的语义动作<h2 id="属性文法-上下文无关文法与程序语义的桥梁"><a href="#属性文法-上下文无关文法与程序语义的桥梁" class="headerlink" title="属性文法-上下文无关文法与程序语义的桥梁"></a>属性文法-上下文无关文法与程序语义的桥梁</h2></li><li>亦称为翻译文法</li><li>在上下文无关文法的基础上, 为每个文法符号配备若干相关的”值”(属性)<ul><li>属性代表与文法相关的信息</li><li>属性可以进行运算与传递</li><li>语义规则: 对于文法的每个产生式都配备了一组属性的计算规则<h2 id="基础文法"><a href="#基础文法" class="headerlink" title="基础文法"></a>基础文法</h2></li></ul></li><li>每个文法符号有一组属性</li><li>每个文法产生式A ⟶ α, 有一组形式为b:=f(c1,c2,…,ck)的语义规则, 其中f为函数, b和c1,c2,…,ck是该产生式文法符号的属性<ul><li>综合属性:如果b是A的属性, c1,c2,…,ck是产生式右部文法符号的属性或A的其他属性<br>属性值由分析树中其子节点的属性值来计算</li><li>继承属性:如果b是产生式右部某个文法符号X的属性, c1,c2,…,ck是产生式右部文法符号的属性或A的其他属性<br>属性值由结点的兄弟结点及父结点的属性值来计算</li><li>对<strong>语义规则</strong>b:=f(c1,c2,…,ck), 函数f通常为表达式(形如T.val=F.val), 或者一些产生副作用的操作(形如print(E.val)打印), 可以看作产生式左部非终结符的<em>虚拟综合属性</em></li></ul></li><li>一般而言:<ul><li>终结符只有综合属性, 并且这些综合属性通常由词法分析器提供</li><li>非终结符既可以有综合属性也可以有继承属性, 文法的开始符号一般没有继承属性, 除非特殊说明</li><li>文法符号的综合属性集和继承属性集的交集应当为空</li><li>对出现在<em>产生式右边的继承属性</em>以及出现在<em>产生式左边的综合属性</em>都必须提供一个计算规则, 属性计算规则中只能使用相应产生式中的文法符号的属性</li><li>对出现在<em>产生式左边的继承属性</em>以及出现在<em>产生式右边的综合属性</em>不由所给的产生式的属性计算规则进行计算, 他们由其他产生式的属性规则计算或由属性计算器的参数提供<h3 id="注释分析树-分析树-属性"><a href="#注释分析树-分析树-属性" class="headerlink" title="注释分析树: 分析树+属性"></a>注释分析树: 分析树+属性</h3></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法制导&quot;&gt;&lt;a href=&quot;#语法制导&quot; class=&quot;headerlink&quot; title=&quot;语法制导&quot;&gt;&lt;/a&gt;语法制导&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-文法分析-自下而上分析</title>
    <link href="http://qidianxuan.github.io/2019/12/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/12/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/</id>
    <published>2019-12-08T08:28:50.000Z</published>
    <updated>2019-12-10T02:17:06.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="规约-对应最右推导的逆过程"><a href="#规约-对应最右推导的逆过程" class="headerlink" title="规约: 对应最右推导的逆过程"></a>规约: 对应最右推导的逆过程</h3><h3 id="句柄-和某产生式右部匹配的子串"><a href="#句柄-和某产生式右部匹配的子串" class="headerlink" title="句柄: 和某产生式右部匹配的子串"></a>句柄: 和某产生式右部匹配的子串</h3><ul><li>句柄是句型的一个字串</li><li>把句柄<strong>规约</strong>为非终结符代表了某一步最右推导的逆过程</li><li>句柄的右边只有终结符</li><li>若文法二义, 则句柄不唯一<h2 id="移进-规约分析"><a href="#移进-规约分析" class="headerlink" title="移进-规约分析"></a>移进-规约分析</h2></li><li>输入: 以$结尾的句子</li><li>栈: 栈底为$的栈</li><li>分析表: 确定下一步动作为移进还是规约</li><li>分析程序<ul><li>四种动作<ul><li>移进: 下一个输入符号压栈</li><li>规约: 确定使用那个产生式</li><li>接受: 输出分析成功</li><li>报错: 发生语法错误, 调用错误恢复例程</li></ul></li><li>对于每个字符, 若可规约则规约, 不可规约则继续移进判断可否规约(查表)</li></ul></li><li>移进-规约分析的冲突<ul><li>要移进还是规约?</li></ul></li><li>规约-规约冲突<ul><li>选择那个产生式进行规约?</li></ul></li></ul><a id="more"></a><h2 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h2><p>LR分析器处理LR(k)文法</p><ul><li>k指决定分析动作时向前看的符号个数, k=1时省略</li><li>LR分析器采用LR分析方法</li><li>特点:<ul><li>适用于上下文无关文法</li><li>效率高</li></ul></li><li>三种技术<ul><li>简单的LR方法, 简称SLR</li><li>规范的LR方法</li><li>向前看的LR方法, 简称LALR</li></ul></li><li>格局(Configuration)<ul><li>二元组 $(s_0X_1s_1X_2…X_ms_m, a_ia_{i+1}…a_n\$) $</li><li>作为栈的内容, 右边为未处理的串</li><li>$ X_i$ 为文法符号, $s_i$为状态</li><li>在某个时刻, 该格局的状态总为右句型$ X_1X_2…X_ma_ia_{i+1}…a_n $</li></ul></li><li>结构:<ul><li>输入: 以$结尾的句子</li><li>栈: 元素为符号和状态 </li><li>LR分析表Action[s,a]和Goto[s,A]</li></ul></li><li>算法:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = w$的第一个符号, w为句子;</span><br><span class="line">栈顶此时为s0</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s = 栈顶状态;</span><br><span class="line">    <span class="keyword">if</span>(Action[s,a]==移进状态t)&#123;</span><br><span class="line">        把a和t依次压入栈;</span><br><span class="line">        a = 下一个输入符号;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Action[s,a]==规约A-&gt;b)&#123;</span><br><span class="line">        栈顶退掉<span class="number">2</span>*|b|个符号, |b|为b的长度</span><br><span class="line">        t = 栈顶状态;</span><br><span class="line">        A和<span class="keyword">goto</span>[t,A]压入栈;</span><br><span class="line">        输出(打印)产生式A-&gt;b</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Action[s,a]==接受)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        调用错误恢复例程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>右句型的前缀, 该前缀不超过最右句柄的右端</p><ul><li>右句型: 进行最右推导时形成的句型</li><li>前缀: 一个符号串的前缀是指从第一个符号开始的连续若干符号构成的字串(可以为空)</li><li>定义:<br>对于推导S ⟹ <em>$_{rm}$Aw ⟹ $_{rm}$ybw<br>yb的任何前缀(包括ε和yb本身)都是一个活前缀<br>简单的来说, 即<em>*分析栈里面出现的串</em></em><h4 id="活前缀与句柄的关系"><a href="#活前缀与句柄的关系" class="headerlink" title="活前缀与句柄的关系"></a>活前缀与句柄的关系</h4></li><li>活前缀已经含有句柄的全部符号, 则证明产生式A⟶β的右部β已经出现在栈顶</li><li>活前缀只含有句柄的一部分符号,如对A⟶β1β2, 若活前缀只含一部分符号β1,则说明β1已经出现在栈顶, 当前期待看到从β2推出的符号</li><li>活前缀不含句柄任何符号, 则期望产生式A⟶β右部推出的符号串<h3 id="SLR"><a href="#SLR" class="headerlink" title="SLR"></a>SLR</h3><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h4>在右部的某个地方加点的产生式<br>  如对A ⟶ XYZ, 有A ⟶ ·XYZ 或A ⟶ X·YZ等<br>  对于A ⟶ ε, 有A ⟶ ·<br>  点的左边表示已经看到的部分, 右边为期望的部分<h4 id="LR-0-项目集"><a href="#LR-0-项目集" class="headerlink" title="LR(0)项目集"></a>LR(0)项目集</h4>若干个LR(0)项目的集合<h4 id="从文法构造识别活前缀的DFA"><a href="#从文法构造识别活前缀的DFA" class="headerlink" title="从文法构造识别活前缀的DFA"></a>从文法构造识别活前缀的DFA</h4></li><li><p>拓广文法<br>考虑文法:  </p><pre><code>      E ⟶ E + T | T         T ⟶ T * F | F         F ⟶ (E) | id   </code></pre><p>  无法判断其起始符号, 因为起始符号E出现在了产生式右端<br>  所以加入如下产生式:     </p><pre><code>      E&#39; ⟶ E  </code></pre></li></ul><p>使得起始符号位E’, 这样的文法为<strong>拓广文法</strong></p><ul><li><p>构建LR(0)项目集的规范族(依然考虑上述文法)</p><ol><li><p>闭包函数closure(I)</p><ul><li>I的每个项目均加入closure(I)中</li><li>如果A ⟶ α·Bβ在closure(I)中,且B ⟶ ·γ还不在closure(I))中的话,则将其加入(α,β可为空)</li></ul></li><li><p>首先由构造状态$I_0$, 由E’ ⟶ E生成, 应包括其所有闭包<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/I0_.jpg" alt></p></li><li><p>再观察状态$I_0$可能碰到的符号, 计算$I_1$:=goto($I_0$,X), 即满足[A ⟶ α·Xβ]的属于$I_0$的所有项目[A ⟶ αX·β]的<strong>闭包</strong><br>如下图$I_1$为$I_0$碰到E时的情况<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/I1.jpg" alt></p></li><li><p>考虑所有的情况,写作$I_x$,并作出DFA:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Ifin.jpg" alt></p></li><li><p>从DFA构造SLR分析表<br>对于状态i从$I_i$构造, 它的action函数如下确定:</p></li></ol><ul><li>若[A ⟶ α·aβ]在$I_i$中, 并且goto($I_i$,a)=$I_j$, 那么置action[i,a]为sj</li><li>若[A ⟶ α·]在$I_i$中, 那么对FOLLOW(A)中的所有a, 置action[i,a]为rj, j是产生式A ⟶ α的编号</li><li>若[S’ ⟶ S·]在$I_i$中, 那么置action[i,$]为接受状态acc<br>对于状态i的goto函数  </li><li><p>对所有的非终结符A, 如果goto($I_i$,A)=$I_j$, 那么goto[i,A]=j<br>其余为ERROR, 出现冲突则该文法并非SLR(1)  </p><pre><code>  以E ⟶ T·, T ⟶ T·*F为例    FOLLOW(E)={$,+,)},则action[2,$]=action[2,+]=action[2,)]=r2   action[2,*]=s7</code></pre></li></ul></li></ul><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><ul><li>SLR文法描述能力有限<h4 id="前向搜索符"><a href="#前向搜索符" class="headerlink" title="前向搜索符"></a>前向搜索符</h4></li><li>对于一个项目 A ⟶ α·β, 如果最终利用这个产生式进行规约之后, 希望看到的符号为a, 则该项目的前向搜索符为a</li><li>则上述项目写为A ⟶ α·β, a<h4 id="LR-1-项目"><a href="#LR-1-项目" class="headerlink" title="LR(1)项目"></a>LR(1)项目</h4></li><li>带上搜索符的LR(0)项目</li><li>LR(1)项目[A ⟶ α·β, a]对活前缀γ<strong>有效</strong>:<ul><li>如果存在推导S ⟹ *$_{rm}$δAω ⟹ $_{rm}$δαβω, 其中γ = δα, a是ω的第一个符号, 或者ω是ε且a是$(即β后只能跟a或\$)</li></ul></li><li>对于项目[A ⟶ α·β, a]<ul><li>当β不为空时, 采取移进操作</li><li>当β为空时, 根据搜索符a而并非A后继符FOLLOW(A)来进行规约(区别于LR(0)), 通常a的集合为FOLLOW(A)的子集</li></ul></li><li>项目集计算闭包函数closure(I)<ul><li>I中的任何项目都属于closure(I)</li><li>若有项目[A ⟶ α·Bβ, a]在closure(I)中, 而B ⟶ γ是文法中的产生式, b是FIRST(βa)中的元素, 则[B ⟶ ·γ,b]也属于closure(I)</li></ul></li><li><p>考虑文法</p><blockquote><p>S’ ⟶ S<br>S ⟶ BB<br>B ⟶ bB<br>B ⟶ a</p></blockquote><p>  参照SLR的方法构建状态转换图:<br>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LR_1.jpg" alt></p></li><li><p>构造分析表:<br>从$I_i$构造分析器的状态i, 器action函数如下确定:  </p><ul><li>如果[A ⟶ α·aβ, b]在$I_i$中, 且goto($I_i$,a)=$I_j$, 那么置action[i,a]为sj</li><li>如果[A ⟶ a·, a]在$I_i$中, 且A ≠ S’, 那么置action[i,a]为rj</li><li><p>如果[S’ ⟶ S·, $]在$I_i$中, 那么置action[i,$]为acc</p><p>状态i的goto函数如下确定:</p></li><li>若goto($I_i$,A) = $I_j$, 那么goto[i,A] = j<br>初始状态为[S’ ⟶ S, $], 上述未定义为error</li></ul></li></ul><h3 id="LALR"><a href="#LALR" class="headerlink" title="LALR"></a>LALR</h3><p>LR状态表数目较多</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ul><li>合并LR(1)文法的活前缀的DFA中的同心项目集<ul><li>同心的LR(1)项目集:<ul><li>略去搜索符后他们是相同的集合</li></ul></li></ul></li></ul><p>合并前:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LALRA.jpg" alt><br>合并后:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LALRB.jpg" alt></p><h4 id="合并后可能引起的冲突"><a href="#合并后可能引起的冲突" class="headerlink" title="合并后可能引起的冲突"></a>合并后可能引起的冲突</h4><ul><li>不会引起新的移进-规约冲突</li><li>有可能引起新的规约-规约冲突</li></ul><h4 id="按构造LR-1-分析表的方式进行构造分析表"><a href="#按构造LR-1-分析表的方式进行构造分析表" class="headerlink" title="按构造LR(1)分析表的方式进行构造分析表"></a>按构造LR(1)分析表的方式进行构造分析表</h4><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="LR-1"><a href="#LR-1" class="headerlink" title="LR"></a>LR</h3><ol><li>栈中的文法总是一个活前缀</li><li>分析表的转移函数实际上是识别活前缀的DFA</li><li>栈顶的状态符号包含了确定句柄所需要的一切信息</li><li>最一般的无回溯的移进-规约方法</li><li>能分析的文法类是预测分析法能分析的文法类的真超集</li><li>能及时发现错误<br> 但手工构造分析表工作量太大!<h3 id="比较表格"><a href="#比较表格" class="headerlink" title="比较表格"></a>比较表格</h3></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">LR(1)</th><th style="text-align:center">LL(1)</th></tr></thead><tbody><tr><td style="text-align:center">建立分析树的方式</td><td style="text-align:center">自上而下</td><td style="text-align:center">自下而上</td></tr><tr><td style="text-align:center">规约还是推导</td><td style="text-align:center">规范规约</td><td style="text-align:center">最左推导</td></tr><tr><td style="text-align:center">决定使用产生式的时机</td><td style="text-align:center">看见产生式整个右部推出的东西才规约</td><td style="text-align:center">看见产生式右部推出的第一个终结符就进行推导</td></tr><tr><td style="text-align:center">对文法的显式限制</td><td style="text-align:center">没有</td><td style="text-align:center">无左递归,无公共左因子</td></tr><tr><td style="text-align:center">分析表比较</td><td style="text-align:center">状态×文法符号导致分析表大</td><td style="text-align:center">非终结符×终结符,分析表小</td></tr><tr><td style="text-align:center">栈比较</td><td style="text-align:center">状态栈</td><td style="text-align:center">文法符号栈</td></tr><tr><td style="text-align:center">确定句柄</td><td style="text-align:center">根据栈顶状态和下一个符号便可以确定句柄及规约用产生式</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">语法错误</td><td style="text-align:center">出现则报错</td><td style="text-align:center">出现则报错</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;规约-对应最右推导的逆过程&quot;&gt;&lt;a href=&quot;#规约-对应最右推导的逆过程&quot; class=&quot;headerlink&quot; title=&quot;规约: 对应最右推导的逆过程&quot;&gt;&lt;/a&gt;规约: 对应最右推导的逆过程&lt;/h3&gt;&lt;h3 id=&quot;句柄-和某产生式右部匹配的子串&quot;&gt;&lt;a href=&quot;#句柄-和某产生式右部匹配的子串&quot; class=&quot;headerlink&quot; title=&quot;句柄: 和某产生式右部匹配的子串&quot;&gt;&lt;/a&gt;句柄: 和某产生式右部匹配的子串&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;句柄是句型的一个字串&lt;/li&gt;
&lt;li&gt;把句柄&lt;strong&gt;规约&lt;/strong&gt;为非终结符代表了某一步最右推导的逆过程&lt;/li&gt;
&lt;li&gt;句柄的右边只有终结符&lt;/li&gt;
&lt;li&gt;若文法二义, 则句柄不唯一&lt;h2 id=&quot;移进-规约分析&quot;&gt;&lt;a href=&quot;#移进-规约分析&quot; class=&quot;headerlink&quot; title=&quot;移进-规约分析&quot;&gt;&lt;/a&gt;移进-规约分析&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;输入: 以$结尾的句子&lt;/li&gt;
&lt;li&gt;栈: 栈底为$的栈&lt;/li&gt;
&lt;li&gt;分析表: 确定下一步动作为移进还是规约&lt;/li&gt;
&lt;li&gt;分析程序&lt;ul&gt;
&lt;li&gt;四种动作&lt;ul&gt;
&lt;li&gt;移进: 下一个输入符号压栈&lt;/li&gt;
&lt;li&gt;规约: 确定使用那个产生式&lt;/li&gt;
&lt;li&gt;接受: 输出分析成功&lt;/li&gt;
&lt;li&gt;报错: 发生语法错误, 调用错误恢复例程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于每个字符, 若可规约则规约, 不可规约则继续移进判断可否规约(查表)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移进-规约分析的冲突&lt;ul&gt;
&lt;li&gt;要移进还是规约?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规约-规约冲突&lt;ul&gt;
&lt;li&gt;选择那个产生式进行规约?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>复制特殊字符到剪切板</title>
    <link href="http://qidianxuan.github.io/2019/11/30/%E5%A4%8D%E5%88%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    <id>http://qidianxuan.github.io/2019/11/30/%E5%A4%8D%E5%88%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</id>
    <published>2019-11-30T09:10:33.000Z</published>
    <updated>2019-11-30T09:58:14.202Z</updated>
    
    <content type="html"><![CDATA[<html>    <head>        <meta charset="utf-8">        <title>复制特殊字符</title>        <style>            .button{                display: inline-block;                border-radius: 4px;                background-color: #66CCFF;                border: none;                color: #FFFFFF;                text-align: center;                font-size: 22px;                padding: 10px;                width: 100px;                transition: all 0.5s;                cursor: pointer;                margin: 5px;            }            .button span {                cursor: pointer;                display: inline-block;                position: relative;                transition: 0.5s;            }            .button span:after {                content: '»';                position: absolute;                opacity: 0;                top: 0;                right: -20px;                transition: 0.5s;            }            .button:hover span {                padding-right: 25px;            }            .button:hover span:after {                 opacity: 1;                right: 0;            }            body{                font-family: dengxian;            }            p{                font-size: 18px;            }        </style>        <script>            function copyText(text){                var input = document.getElementById("input");                input.value = text;                input.select();                document.execCommand("copy");                alert("复制 "+text+" 成功");            }         </script>    <link rel="alternate" href="/atom.xml" title="qidianxuan's blog" type="application/atom+xml"></head>    <body>        <div id="container">          <textarea id="input" style="width:99%;height: 1%;"></textarea>            <div id="arrow" style="width: auto;height:auto;">                <p style="font:dengxian">箭头</p>                <button class="button" style="vertical-align: middle" onclick="copyText('⟶')"><span>⟶</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟵')"><span>⟵</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟹')"><span>⟹</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟸')"><span>⟸</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇒')"><span>⇒</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇐')"><span>⇐</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇑')"><span>⇑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇓')"><span>⇓</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('→')"><span>→</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('←')"><span>←</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('↑')"><span>↑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('↓')"><span>↓</span></button>            </div>            <div id="set" style="width: auto;height:auto;">                <p style="width: 110px;">集合运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∅')"><span>∅</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∈')"><span>∈</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∉')"><span>∉</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊂')"><span>⊂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊃')"><span>⊃</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊆')"><span>⊆</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊇')"><span>⊇</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋂')"><span>⋂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋃')"><span>⋃</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋁')"><span>⋁</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋀')"><span>⋀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨄')"><span>⨄</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨆')"><span>⨆</span></button>            </div>            <div id="math" style="width: auto;height:auto;">                <p style="width: 110px;">数学运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('±')"><span>±</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('×')"><span>×</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('÷')"><span>÷</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∣')"><span>∣</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∑')"><span>∑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∏')"><span>∏</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≈')"><span>≈</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≡')"><span>≡</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≠')"><span>≠</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≤')"><span>≤</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≥')"><span>≥</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋅')"><span>⋅</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∘')"><span>∘</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨀')"><span>⨀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨂')"><span>⨂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨁')"><span>⨁</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊥')"><span>⊥</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∠')"><span>∠</span></button>            </div>            <div id="integral" style="width: auto;height:auto;">                <p style="width: 110px;">积分运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∫')"><span>∫</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∬')"><span>∬</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∭')"><span>∭</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∮')"><span>∮</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∞')"><span>∞</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∇')"><span>∇</span></button>            </div>            <div id="logic" style="width: auto;height:auto;">                <p style="width: 110px;">逻辑运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∵')"><span>∵</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∴')"><span>∴</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∀')"><span>∀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∃')"><span>∃</span></button>            </div>        </div>    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;复制特殊字符&lt;/title&gt;
        &lt;style&gt;
            .button{
                display:
      
    
    </summary>
    
    
      <category term="小工具" scheme="http://qidianxuan.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-文法分析-自上而下分析</title>
    <link href="http://qidianxuan.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/</id>
    <published>2019-11-29T07:14:29.000Z</published>
    <updated>2019-12-10T02:17:09.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h2><p>利用一般方法, 有可能不能处理左递归, 考虑如下例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E ⟶ E + T | T</span><br><span class="line">T ⟶ T * F | F</span><br><span class="line">F ⟶ ( E ) | id</span><br></pre></td></tr></table></figure><br>存在如下分析树:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Compile3-1.jpg" alt><br>分析树无法做出, 存在无限递归  </p><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p>先定义两个函数:</p><h3 id="FIRST集"><a href="#FIRST集" class="headerlink" title="FIRST集"></a>FIRST集</h3><ul><li><p>FIRST(α) = {a | α ⇒ * a…, a $\sf\in V_T$}  </p><ul><li>FIRST(α)是从α推导出的串的起始终结符的集合    </li><li>特别的是: α ⇒ *ε 时, 规定 ε $\sf\in$ FIRST(α)</li><li>对于A的任何两个选择$\alpha_i$和$\alpha_j$, 希望有FIRST($\alpha_i$)⋂FIRST($\alpha_j$) = ∅<br>但是需要FIRST($\alpha_i$)和FIRST($\alpha_j$)都不含ε</li><li><p>FIRST集合计算方法:</p><ul><li>若X⟶a… 则将终结符a加入FIRST(X)中</li><li>若X⟶ε, 则将ε加入FIRST(X)中</li><li>若X⟶Y…, 且Y为非终结符, 则将FIRST(Y)去除{ε}后加入FIRST(X)中</li><li>若X⟶Y_1Y_2..Y_K,且Y1,Y2,..Yi-1 (2≤i≤k)都是非终结符，且Y1,Y2,..Yi-1 的FIRST集合中均包含ε，则将FIRST(Yj)的所有非ε元素加入到FIRST(X)中，(j=1,2,..i).特别地，若Y1~YK均有ε产生式，则将ε加到FIRST(X)中</li><li><p>例子:</p><pre><code>  S ⟶ BA  A ⟶ BS|d  B ⟶ aA|bS|c  则  FIRST(S) = FIRST(B)   FIRST(A) = FIRST(B) ⋃ {d}  FIRST(B) = {a,b,c}</code></pre></li></ul></li></ul></li></ul><a id="more"></a><h3 id="FOLLOW集"><a href="#FOLLOW集" class="headerlink" title="FOLLOW集"></a>FOLLOW集</h3><ul><li><p>FOLLOW(A) = {a | S ⇒ * …Aa…, a $\sf\in V_T$}  </p><ul><li>如果A是某个句型的最右符号(如S⇒*αA), 那么$(结束标记)属于FOLLOW(A)</li><li><p>FOLLOW集合计算方法</p><ol><li>对文法开始符号S,置$于FOLLOW(S)中</li><li>若有A⟶αBβ, 则将<strong>FIRST</strong>(β)去除{ε}后加入FOLLOW(B)中. (此处α可以为空)</li><li>若A⟶αB 或A⟶αBβ, 且β ⇒* ε(ε属于FIRST(β)), 则将FOLLOW(A)加入FOLLOW(B)中. (此处α可以为空）</li></ol><ul><li><p>例子:</p><pre><code>  S ⟶ BA  A ⟶ BS|d  B ⟶ aA|bS|c  则  第一步(加入$):   由S为开始符, FOLLOW(S) += {$}  此时FOLLOW(S) = {$}  第二步(加入FIRST集合):   由S ⟶ BA, FOLLOW(B) += FIRST(A)  由A ⟶ BS|d, FOLLOW(B) += FIRST(S)  此时FOLLOW(B) = {a,b,c,d}  第三步(判断可加入的FOLLOW集合):  由B ⟶ aA|bS|c  既由B ⟶ aA, 得FOLLOW(A) +=  FIRST(B)  由B ⟶ bS, 得FOLLOW(S) += FIRST(B)  此时FOLLOW(S) = {a,b,c,d,$}, FOLLOW(A) = {a,b,c,d}  再由S ⟶ BA, FOLLOW(A) += FOLLOW(S)  此时FOLLOW(A) = {a,b,c,d,$}  以上</code></pre></li></ul></li></ul></li></ul><h3 id="LL-1-文法-1"><a href="#LL-1-文法-1" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>任意两个产生式A ⟶ α|β 如果他们都满足</p><ul><li>FIRST(α) ⋂ FIRST(β) = ∅</li><li>若β ⇒ *ε , 那么FIRST(α) ⋂ FOLLOW(A) = ∅</li></ul><p>对于LL(1)文法, 有一些明显的性质:</p><ul><li>没有公共左因子</li><li>不是二义的</li><li>不含左递归</li></ul><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">E ⟶ TE<span class="number">'</span></span><br><span class="line">E<span class="number">'</span>⟶ +TE<span class="number">'</span>|ε</span><br><span class="line">T ⟶ FT<span class="number">'</span></span><br><span class="line">T<span class="number">'</span>⟶ *FT<span class="number">'</span>|ε</span><br><span class="line">F ⟶ (E)|id</span><br><span class="line">该文法是LL(<span class="number">1</span>)文法吗?</span><br><span class="line"><span class="number">1.</span> 先求出FIRST集合</span><br><span class="line">FIRST(E) = &#123;(,id&#125;</span><br><span class="line">FIRST(T) = &#123;(,id&#125;</span><br><span class="line">FIRST(F) = &#123;(,id&#125;</span><br><span class="line">FIRST(E<span class="number">'</span>) = &#123;+,ε&#125;</span><br><span class="line">FIRST(T<span class="number">'</span>) = &#123;*,ε&#125;</span><br><span class="line"><span class="number">2.</span> 求各FOLLOW集合</span><br><span class="line">由规则<span class="number">1</span>:</span><br><span class="line">E为起始符, 则FOLLOW(E) += &#123;$&#125;</span><br><span class="line">由规则<span class="number">2</span>:</span><br><span class="line">由F ⟶ (E), 得FOLLOW(E) += &#123;)&#125; 此时FOLLOW(E) = &#123;),$&#125;</span><br><span class="line">由E ⟶ TE<span class="number">'</span>, 得FOLLOW(T) += FIRST(E<span class="number">'</span>) 此时FOLLOW(T) = &#123;+,),$&#125; </span><br><span class="line">由T ⟶ FT<span class="number">'</span>, 得FOLLOW(F) += FIRST(T<span class="number">'</span>) 此时FOLLOW(F) = &#123;*,),$&#125;</span><br><span class="line">由规则<span class="number">3</span>:</span><br><span class="line">由E ⟶ TE<span class="number">'</span>, 得FOLLOW(T) += FOLLOW(E) 此时FOLLOW(T) = &#123;+,),$&#125; </span><br><span class="line">由T ⟶ FT<span class="number">'</span>, 得FOLLOW(F) += FOLLOW(T) 此时FOLLOW(F) = &#123;+,*,),$&#125;</span><br><span class="line">再有:</span><br><span class="line">FOLLOW(E<span class="number">'</span>) = FOLLOW(E)</span><br><span class="line">FOLLOW(T<span class="number">'</span>) = FOLLOW(T)</span><br><span class="line"><span class="number">3.</span> 判断</span><br><span class="line">对于E<span class="number">'</span>⟶ +TE<span class="number">'</span>|ε</span><br><span class="line">FIRST(+TE<span class="number">'</span>) = &#123;+&#125;</span><br><span class="line">FOLLOW(E<span class="number">'</span>) = &#123;),$&#125;</span><br><span class="line">FIRST(+TE<span class="number">'</span>) ⋂ FOLLOW(E<span class="number">'</span>) = ∅</span><br><span class="line">对于T<span class="number">'</span>⟶ *FT<span class="number">'</span>|ε</span><br><span class="line">FIRST(*FT<span class="number">'</span>) = &#123;*&#125;</span><br><span class="line">FOLLOW(T<span class="number">'</span>) = &#123;+,),$&#125;</span><br><span class="line">FIRST(*FT<span class="number">'</span>) ⋂ FOLLOW(T<span class="number">'</span>) = ∅</span><br><span class="line">该文法为LL(<span class="number">1</span>)文法</span><br></pre></td></tr></table></figure><h2 id="自上而下分析实现"><a href="#自上而下分析实现" class="headerlink" title="自上而下分析实现"></a>自上而下分析实现</h2><h3 id="递归函数法"><a href="#递归函数法" class="headerlink" title="递归函数法"></a>递归函数法</h3><ul><li>为每个非终结符都写一个分析过程</li><li>过程可能存在递归<br>举例:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于文法</span></span><br><span class="line"><span class="comment">S ⟶ BA</span></span><br><span class="line"><span class="comment">A ⟶ BS|d</span></span><br><span class="line"><span class="comment">B ⟶ aA|bS|c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">需要实现如下函数</span><br><span class="line">S()&#123;</span><br><span class="line">    B();</span><br><span class="line">    A();</span><br><span class="line">&#125;</span><br><span class="line">A()&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead==<span class="string">'a'</span>|<span class="string">'b'</span>|<span class="string">'c'</span>)&#123;</span><br><span class="line">        B();</span><br><span class="line">        S();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'d'</span>)</span><br><span class="line">        match(<span class="string">'d'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead==<span class="string">'a'</span>)&#123;</span><br><span class="line">        match(<span class="string">'a'</span>);</span><br><span class="line">        A();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'b'</span>)&#123;</span><br><span class="line">        match(<span class="string">'b'</span>);</span><br><span class="line">        S();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'c'</span>)</span><br><span class="line">        match(<span class="string">'c'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br><span class="line">match(<span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead == c)</span><br><span class="line">        lookahead = nextToken();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归的预测分析法"><a href="#非递归的预测分析法" class="headerlink" title="非递归的预测分析法"></a>非递归的预测分析法</h3><ul><li><p>构造预测分析表, 按照如下流程图:<br>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Chartmake.png" alt><br>  举例:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">文法:</span><br><span class="line">S ⟶ ACD</span><br><span class="line">A ⟶ a|ε</span><br><span class="line">C ⟶ c</span><br><span class="line">D ⟶ d</span><br><span class="line">其FIRST集合:</span><br><span class="line">FIRST(S) = &#123;a, c&#125;</span><br><span class="line">FIRST(A) = &#123;a, ε&#125;</span><br><span class="line">FIRST(C) = &#123;c&#125;</span><br><span class="line">FIRST(D) = &#123;d&#125;</span><br><span class="line">其FOLLOW集合:</span><br><span class="line">FOLLOW(S) = &#123;$&#125;</span><br><span class="line">FOLLOW(A) = &#123;c&#125;</span><br><span class="line">FOLLOW(C) = &#123;d&#125;</span><br><span class="line">FOLLOW(D) = &#123;$&#125;</span><br><span class="line">则其预测分析表为</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/ChartExam.jpg" alt></p><ul><li>若文法为二义的, 将会出现一格内有两项的问题.</li><li>算法实现:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入: 串w和文法G的分析表M</span></span><br><span class="line"><span class="comment">//输出: 是否符合文法, 符合则输出w的左推导</span></span><br><span class="line"></span><br><span class="line">ip = w$的第一个符号</span><br><span class="line">X = 栈顶元素</span><br><span class="line"><span class="keyword">while</span>(X!=$)&#123;</span><br><span class="line">    <span class="keyword">if</span> (X为a) 把X弹出并把ip推向下一个符号</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X为终结符)</span><br><span class="line">        把X从栈顶弹出, ip入栈, ip指向下一个符号</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为ERROR)</span><br><span class="line">        error();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为X ⟶ Y1Y2...Yk)&#123;</span><br><span class="line">        输出产生式;</span><br><span class="line">        栈中弹出X;</span><br><span class="line">        把Yk...Y2Y1依次压入栈, Y1在栈顶</span><br><span class="line">    &#125; </span><br><span class="line">    令X为栈顶元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提:&quot;&gt;&lt;/a&gt;前提:&lt;/h2&gt;&lt;p&gt;利用一般方法, 有可能不能处理左递归, 考虑如下例子&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;E ⟶ E + T | T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;T ⟶ T * F | F&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F ⟶ ( E ) | id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;存在如下分析树:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Compile3-1.jpg&quot; alt&gt;&lt;br&gt;分析树无法做出, 存在无限递归  &lt;/p&gt;&lt;h2 id=&quot;LL-1-文法&quot;&gt;&lt;a href=&quot;#LL-1-文法&quot; class=&quot;headerlink&quot; title=&quot;LL(1)文法&quot;&gt;&lt;/a&gt;LL(1)文法&lt;/h2&gt;&lt;p&gt;先定义两个函数:&lt;/p&gt;&lt;h3 id=&quot;FIRST集&quot;&gt;&lt;a href=&quot;#FIRST集&quot; class=&quot;headerlink&quot; title=&quot;FIRST集&quot;&gt;&lt;/a&gt;FIRST集&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;FIRST(α) = {a | α ⇒ * a…, a $\sf\in V_T$}  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIRST(α)是从α推导出的串的起始终结符的集合    &lt;/li&gt;
&lt;li&gt;特别的是: α ⇒ *ε 时, 规定 ε $\sf\in$ FIRST(α)&lt;/li&gt;
&lt;li&gt;对于A的任何两个选择$\alpha_i$和$\alpha_j$, 希望有FIRST($\alpha_i$)⋂FIRST($\alpha_j$) = ∅&lt;br&gt;但是需要FIRST($\alpha_i$)和FIRST($\alpha_j$)都不含ε&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FIRST集合计算方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若X⟶a… 则将终结符a加入FIRST(X)中&lt;/li&gt;
&lt;li&gt;若X⟶ε, 则将ε加入FIRST(X)中&lt;/li&gt;
&lt;li&gt;若X⟶Y…, 且Y为非终结符, 则将FIRST(Y)去除{ε}后加入FIRST(X)中&lt;/li&gt;
&lt;li&gt;若X⟶Y_1Y_2..Y_K,且Y1,Y2,..Yi-1 (2≤i≤k)都是非终结符，且Y1,Y2,..Yi-1 的FIRST集合中均包含ε，则将FIRST(Yj)的所有非ε元素加入到FIRST(X)中，(j=1,2,..i).特别地，若Y1~YK均有ε产生式，则将ε加到FIRST(X)中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  S ⟶ BA
  A ⟶ BS|d
  B ⟶ aA|bS|c
  则
  FIRST(S) = FIRST(B) 
  FIRST(A) = FIRST(B) ⋃ {d}
  FIRST(B) = {a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Tips of an Interview</title>
    <link href="http://qidianxuan.github.io/2019/11/27/Tips-of-an-Interview/"/>
    <id>http://qidianxuan.github.io/2019/11/27/Tips-of-an-Interview/</id>
    <published>2019-11-27T10:41:30.000Z</published>
    <updated>2019-11-27T10:59:00.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Attentive-Listening-in-an-Interview"><a href="#Attentive-Listening-in-an-Interview" class="headerlink" title="Attentive Listening in an Interview"></a>Attentive Listening in an Interview</h1><h2 id="1-Listen-for-hidden-questions"><a href="#1-Listen-for-hidden-questions" class="headerlink" title="1. Listen for hidden questions"></a>1. Listen for hidden questions</h2><h3 id="Interviewer-want-to-know-3-things"><a href="#Interviewer-want-to-know-3-things" class="headerlink" title="Interviewer want to know 3 things:"></a>Interviewer want to know 3 things:</h3><ol><li>CAN you do the job?</li><li>WILL you do the job?</li><li>Do you fit?</li></ol><a id="more"></a><h3 id="How-to-answer-these-questions"><a href="#How-to-answer-these-questions" class="headerlink" title="How to answer these questions?"></a>How to answer these questions?</h3><p>Use SAR model</p><ul><li>Situation</li><li>Action Taken</li><li>Result</li></ul><h2 id="2-Listen-to-what-the-interviewer-actually-saying"><a href="#2-Listen-to-what-the-interviewer-actually-saying" class="headerlink" title="2. Listen to what the interviewer actually saying"></a>2. Listen to what the interviewer actually saying</h2><ul><li>tone of voice</li><li>facial expression &amp; body language</li><li>place yourself in interveiewer’s position</li></ul><h2 id="3-Ask-for-more-information"><a href="#3-Ask-for-more-information" class="headerlink" title="3. Ask for more information"></a>3. Ask for more information</h2><ul><li>when you need additional information</li><li>rephrase the question</li><li>Interpret what you hear</li></ul><h2 id="4-Listen-to-get-the-interviewer’s-attention"><a href="#4-Listen-to-get-the-interviewer’s-attention" class="headerlink" title="4. Listen to get the interviewer’s attention"></a>4. Listen to get the interviewer’s attention</h2><p>Active listening will allow you </p><ul><li>SPOT on them</li><li>Capitalize on them</li></ul><h1 id="Common-interview-questions"><a href="#Common-interview-questions" class="headerlink" title="Common interview questions"></a>Common interview questions</h1><h2 id="Small-talk"><a href="#Small-talk" class="headerlink" title="Small talk"></a>Small talk</h2><p>you shall:</p><ul><li>be poilet and friendly</li><li>Keep your answers short</li><li>Feel free to turn the questions back to the interviewer</li><li>practice small talk on your own asking yourself simple, easy-to-answer, non-personal questions<h3 id="COMMON-QUESTION-1-Tell-me-a-little-bit-about-yourself"><a href="#COMMON-QUESTION-1-Tell-me-a-little-bit-about-yourself" class="headerlink" title="COMMON QUESTION 1: Tell me a little bit about yourself."></a>COMMON QUESTION 1: Tell me a little bit about yourself.</h3></li><li>Education and work history<h3 id="COMMON-QUESTION-2-Can-you-tell-me-how-you-heard-about-this-position"><a href="#COMMON-QUESTION-2-Can-you-tell-me-how-you-heard-about-this-position" class="headerlink" title="COMMON QUESTION 2: Can you tell me how you heard about this position?"></a>COMMON QUESTION 2: Can you tell me how you heard about this position?</h3></li><li>Share a little bit of reserch you have been done in order to learn the position that you are planning for.</li><li>Share if someone inside the company let you know the position<h3 id="COMMON-QUESTION-3-What-attracted-you-to-ur-company"><a href="#COMMON-QUESTION-3-What-attracted-you-to-ur-company" class="headerlink" title="COMMON QUESTION 3: What attracted you to ur company?"></a>COMMON QUESTION 3: What attracted you to ur company?</h3></li><li>Share what you learn about the company</li><li>Why you would like to work there<h3 id="COMMON-QUESTION-4-What-would-you-say-is-your-grestest-strengthen"><a href="#COMMON-QUESTION-4-What-would-you-say-is-your-grestest-strengthen" class="headerlink" title="COMMON QUESTION 4: What would you say is your grestest strengthen?"></a>COMMON QUESTION 4: What would you say is your grestest strengthen?</h3></li><li>Chance to share what you do really well as an employee and as a person</li><li>You can share what your greatest strengthen is, then explain how that helps you in your current job or life<h3 id="COMMON-QUESTION-5-Can-you-tell-me-about-a-time-when-you-suffered-a-setback-and-had-to-maintain-your-enthusiasm"><a href="#COMMON-QUESTION-5-Can-you-tell-me-about-a-time-when-you-suffered-a-setback-and-had-to-maintain-your-enthusiasm" class="headerlink" title="COMMON QUESTION 5: Can you tell me about a time when you suffered a setback and had to maintain your enthusiasm?"></a>COMMON QUESTION 5: Can you tell me about a time when you suffered a setback and had to maintain your enthusiasm?</h3></li><li>Know how you behave in a certain stress or situations<h3 id="COMMON-QUESTION-6-What-do-you-consider-to-be-your-greatest-weakness"><a href="#COMMON-QUESTION-6-What-do-you-consider-to-be-your-greatest-weakness" class="headerlink" title="COMMON QUESTION 6: What do you consider to be your greatest weakness?"></a>COMMON QUESTION 6: What do you consider to be your greatest weakness?</h3></li><li>To be honest</li><li>Share a weakness, like public speaking, or attention to detail, fear of failure.</li><li>Then talk about ways you’ve worked on improvement in that area.<h3 id="COMMON-QUESTION-7-Where-do-you-see-yourself-in-five-years"><a href="#COMMON-QUESTION-7-Where-do-you-see-yourself-in-five-years" class="headerlink" title="COMMON QUESTION 7: Where do you see yourself in five years?"></a>COMMON QUESTION 7: Where do you see yourself in five years?</h3></li><li>Chance to share your goals for the future.</li><li>You understand what is realistically achieveable over a certain period of time.</li><li>Let the interviewer know how ambitious you are with this answer.<h3 id="COMMON-QUESTION-8-Do-you-have-any-questions-for-me"><a href="#COMMON-QUESTION-8-Do-you-have-any-questions-for-me" class="headerlink" title="COMMON QUESTION 8: Do you have any questions for me?"></a>COMMON QUESTION 8: Do you have any questions for me?</h3></li><li>Find out if the company is a good fit for you.</li><li>The question you ask will also show how well you know ablut the company and the requirements of the position.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Attentive-Listening-in-an-Interview&quot;&gt;&lt;a href=&quot;#Attentive-Listening-in-an-Interview&quot; class=&quot;headerlink&quot; title=&quot;Attentive Listening in an Interview&quot;&gt;&lt;/a&gt;Attentive Listening in an Interview&lt;/h1&gt;&lt;h2 id=&quot;1-Listen-for-hidden-questions&quot;&gt;&lt;a href=&quot;#1-Listen-for-hidden-questions&quot; class=&quot;headerlink&quot; title=&quot;1. Listen for hidden questions&quot;&gt;&lt;/a&gt;1. Listen for hidden questions&lt;/h2&gt;&lt;h3 id=&quot;Interviewer-want-to-know-3-things&quot;&gt;&lt;a href=&quot;#Interviewer-want-to-know-3-things&quot; class=&quot;headerlink&quot; title=&quot;Interviewer want to know 3 things:&quot;&gt;&lt;/a&gt;Interviewer want to know 3 things:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;CAN you do the job?&lt;/li&gt;
&lt;li&gt;WILL you do the job?&lt;/li&gt;
&lt;li&gt;Do you fit?&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="English" scheme="http://qidianxuan.github.io/categories/English/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-文法分析-上下文无关文法,文法和语言</title>
    <link href="http://qidianxuan.github.io/2019/11/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/"/>
    <id>http://qidianxuan.github.io/2019/11/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/</id>
    <published>2019-11-25T08:00:24.000Z</published>
    <updated>2019-12-10T01:47:01.895Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://qidianxuan.cn/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">词法分析</a>, 可以将一个字符串转换成记号流, 但是记号流如何转换成语法树, 需要进行语法分析.</p><ul><li>实质: 无结构的数据转化成有结构的数据</li><li>依据: 上下文无关语法</li></ul><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><ul><li>前言<ul><li>正规式来定义一些简单的语言，能表示给定结构的固定次数的重复或者没有指定次数的重复, 但</li><li>正规式不能用于描述配对或嵌套的结构</li></ul></li><li>定义<ul><li>上下文无关文法是四元组( $V_T,V_N,S,P$ )<ul><li>$V_T$: 终结符集合(非空有限集合)</li><li>$V_N$: 非终结符集合( $V_T \bigcap V_N = \emptyset$ )</li><li>S: 开始符号</li><li>P: 产生式集合 ( 产生式形式如$ A \rightarrow \alpha 其中 A \in V_N, \alpha \in (V_T \bigcup V_N)^*$ )</li></ul></li><li>例子<br>$ ( \{id,+, \ast ,-,(,) \} , \{expr,op\} , expr , P ) $<br>其中P包括:<br>expr $ \rightarrow $ expr op expr<br>expr $ \rightarrow $ (expr)<br>expr $ \rightarrow $ -expr<br>expr $ \rightarrow $ id<br>op $ \rightarrow $ +<br>op $ \rightarrow $ *  </li></ul></li><li>优点<ul><li>文法给出了精确的，易于理解的语法说明</li><li>自动产生高效的分析器</li><li>可以给语言定义出层次结构</li><li>以文法为基础的语言的实现便于语言的修改</li></ul></li><li><p>缺点</p><ul><li>文法只能描述编程语言的大部分语法</li></ul></li><li><p>文法推导</p><ul><li>推导: 把产生式看成重写规则，把符号串中的非终结符用其产生式右部的串来代替<br>以文法 $ E \rightarrow E+E|E \ast E|(E)|-E|id$为例:<br>存在代换序列: $ E \Rightarrow E+E \Rightarrow id+E \Rightarrow id+id $<br>这个代换序列即<strong>从E到id+id的推导</strong>,  </li><li>一般而言, 由上下无关文法产生的语言叫<strong>上下文无关语言</strong>  </li><li>若两个文法产生相同的语言, 则称这两个文法<strong>等价</strong>  </li><li>若存在S$\Rightarrow ^\ast \alpha$, 若α含非终结符, 则称其为文法的<strong>句型</strong>, 只含有终结符的句型, 称之为<strong>句子</strong>  </li><li>在推导过程中, 每一步都代换句型中最左边的非终结符的推导,称之为<strong>最左推导</strong>(写作$\alpha \Rightarrow _{lm}\beta$), 类似的,存在<strong>最右推导</strong>(写作$\alpha \Rightarrow _{rm}\beta$), 最右推导亦称为<strong>规范推导</strong></li></ul></li><li>分析树<ul><li>分析树即推导的图形表示.</li><li>例子:<br>以文法 $ E \rightarrow E+E|E \ast E|(E)|-E|id$为例:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/treeexam.jpg" alt="exm.png"><br>对于同样的句子, 其 <em>最终</em> 分析树是一样的, 但过程会有不同.</li></ul></li><li>二义性<ul><li>文法的二义性，是指对于符合文法规则的同一个句子，存在两种可能的分析树</li><li>考虑如下的情况:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/binexam.jpg" alt><br>对于同一个句子, 该句子存在二义性, 分析树存在了不同, 也带来了不同的释义, 左边的为 id*(id+id), 而右边为 (id*id)+id, 但对于句子id*id+id, 一般认为(id*id)+id是正确的</li><li>如何消除二义性, 一般而言, 需要加入<strong>消除二义性的规则</strong></li><li>以文法 $ E \rightarrow E+E|E \ast E|id$为例:<br>可以更改为如下规则:<br>$ E \rightarrow E + T | T $<br>$ E \rightarrow E \ast F | F $<br>$ F \rightarrow id | (E) $</li></ul></li><li>正规式可以描述的语言都可以用上下文无关文法来描述</li><li>NFA转化为上下文无关文法:<ol><li>确定终结符集合</li><li>为每个状态引入一个非终结符$A_i$</li><li>如果状态i有一个转换a到状态j, 则引入产生式$A_i \rightarrow aA_i $, 如果i是接收状态, 则引入$A_i \rightarrow \epsilon$<br>例子:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfa2lex.jpg" alt></li></ol></li><li>为什么要用正规式定义词法 <ul><li>词法规则非常简单,不必用上下文无关文法</li><li>对于词法记号,正规式描述简洁且易于理解</li><li>从正规式构造出的词法分析器效率高</li></ul></li><li>把词法分析从语法分析中分离出来的理由 <ul><li>简化设计</li><li>编译器的效率会改进</li><li>编译器的可移植性加强</li><li>便于编译器前端的模块划分</li></ul></li><li>能否把词法分析并入到语法分析中,直接从字符流进行语法分析?<ul><li>若把词法分析和语法分析合在一起，则必须将语言的注解和空白的规则反映在文法中，文法将大大复杂</li><li>注解和空白由自己来处理的分析器，比注解和空格已由词法分析器删除的分析器要复杂得多</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;https://qidianxuan.cn/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="http://qidianxuan.github.io/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2019-11-24T05:27:15.000Z</published>
    <updated>2019-12-17T13:56:21.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><ul><li>词法分析器: 把构成源程序的字符流翻译成记号(token)流，还完成和用户接口的一些任务<br>  其中:<ul><li>词法单元: 亦称单词, 编程语言中合法的字符串</li><li>词法记号: 满足某种给定规则(模式)的词法单元<br>示例: 对于词法记号NUM, 其词法单元可能有3.1, 10, 2.8E12等数字, 其”模式”即”认定为数字的字符串”</li></ul></li></ul><a id="more"></a><h2 id="串和语言"><a href="#串和语言" class="headerlink" title="串和语言"></a>串和语言</h2><ul><li>字母表: 符号的有限集合.   示例: Σ = {0,1}</li><li>串: 符号的有穷序列.       示例: 0110,ε(长度为0的空串)<br>运算:<ul><li>连接: xy, 其中sε = εs = s</li><li>积: $s^0 = \epsilon , s^i = s^{i-1}s(i&gt;0)$</li></ul></li><li>语言: 字母表上的一个串集. 示例: {ε, 0, 11, …}, {ε}, ∅<br>运算:<ul><li>和:$\sf L \bigcup M = \{s|s \in L 或 s \in M \}$</li><li>连接:$\sf LM = \{st|s \in L 且 s \in M\}$</li><li>指数:$\sf L^0=\{ε\}, L^i = L^{i-1}L$</li><li>闭包:$\sf L^* = L^0\bigcup L^1\bigcup L^2\bigcup …$</li><li>正闭包:$\sf L^+ = L^1 \bigcup L^2 \bigcup … 并且 L^* = L^0 \bigcup L^+$</li></ul></li></ul><h2 id="正规式-正则表达式"><a href="#正规式-正则表达式" class="headerlink" title="正规式(正则表达式)"></a>正规式(正则表达式)</h2><ul><li>正规式: 按照一定的定义规则, 由较简单的正规式构成, 每个正规式r表示一个<strong>语言</strong>L(r)</li><li>正规式是用于说明词法单元如何对应到词法记号的模式。与非形式化的描述相比，正规式更具形式化，更加精确</li><li>定义如下</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">定义的语言</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center">$\{\epsilon\}$</td><td style="text-align:center">以下定义均在字母表$\sum$中</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">{a}</td><td style="text-align:center">$a \in \sum$</td></tr><tr><td style="text-align:center">r   &#124;  s</td><td style="text-align:center">$\sf L(r) \bigcup L(s)$</td><td style="text-align:center">r和s为正规式</td></tr><tr><td style="text-align:center">rs</td><td style="text-align:center">L(r)L(s)</td><td style="text-align:center">L(r)L(s) = L(s)L(r)</td></tr><tr><td style="text-align:center">$\sf r^*$</td><td style="text-align:center">$\sf L(r)^*$</td><td style="text-align:center">r为正规式</td></tr></tbody></table></div><ul><li>运算符优先级: * &gt; 连接运算 &gt; |</li><li>举例</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">定义的语言</th></tr></thead><tbody><tr><td style="text-align:center">$\sf (a   &#124;  b)(a   &#124;  b)$</td><td style="text-align:center">{aa, ab, ba, bb}</td></tr><tr><td style="text-align:center">$\sf (a   &#124;  b)^*$</td><td style="text-align:center">由a和b构成的所有串集</td></tr></tbody></table></div><h2 id="词法记号的识别"><a href="#词法记号的识别" class="headerlink" title="词法记号的识别"></a>词法记号的识别</h2><ul><li>图形化:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">状态转换图</th></tr></thead><tbody><tr><td style="text-align:center">$\sf d \rightarrow a$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoa2.jpg" alt="dtoa.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoab.jpg" alt="dtoab.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a   &#124;  b$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoaorb.jpg" alt="dtoaorb.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a^*$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoap.jpg" alt="dtoap.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a?$(a出现1次或0次)</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/da.jpg" alt="da.jpg"></td></tr></tbody></table></div><ul><li>举例:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">状态转换图</th></tr></thead><tbody><tr><td style="text-align:center">$\sf d \rightarrow a(a &#124; b)^*$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/FAExample.jpg" alt="faexample.jpg"></td></tr></tbody></table></div><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><ul><li>识别器: 是一个程序，取串x作为输入，当x是语言的句子时，它回答“是”，否则回答“不是”</li><li>状态转换图即有限自动机, 可以作为识别器<h3 id="确定的有限自动机-DFA"><a href="#确定的有限自动机-DFA" class="headerlink" title="确定的有限自动机(DFA)"></a>确定的有限自动机(DFA)</h3></li><li>DFA是一个数学模型, 包括<ul><li>状态集合S</li><li>输入字母表$\sum$</li><li>转换函数$\sf move: S \times \sum \rightarrow S$</li><li>唯一的初态$\sf s \in S$</li><li>终态集合$\sf F \subseteq S$<h3 id="不确定的有限自动机-NFA"><a href="#不确定的有限自动机-NFA" class="headerlink" title="不确定的有限自动机(NFA)"></a>不确定的有限自动机(NFA)</h3></li></ul></li><li>NFA是一个数学模型, 包括<ul><li>状态集合S</li><li>输入字母表$\sf \sum$</li><li>转换函数$\sf move: S \times ( \sum \bigcup \{ \epsilon \})  \rightarrow S$(此处$\epsilon$理解为”未知”)</li><li>唯一的初态$\sf s \in S$</li><li>终态集合$\sf F \subseteq S$<h3 id="DFA与NFA的对比"><a href="#DFA与NFA的对比" class="headerlink" title="DFA与NFA的对比"></a>DFA与NFA的对比</h3></li></ul></li><li>举例:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">DFA</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$(a   &#124;  b)^*ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dfaexam.jpg" alt="dfae.jpg"></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfaexam.jpg" alt="nfae.jpg"></td></tr><tr><td style="text-align:center">状态转移表</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dfachart.jpg" alt></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfachart.jpg" alt></td></tr></tbody></table></div><ol><li>NFA中允许$\epsilon$转换边, 即允许$\epsilon$的输入, 而DFA不允许</li><li>NFA中的move(s,a)可能是个多元集合, 而DFA中的move(s,a)最多一个元素</li><li>DFA:<ul><li>优点: 快速定位</li><li>缺点: 字母表过大或大部分转换状态为空集时浪费空间</li></ul></li><li>NFA:<ul><li>优点: 表较小</li><li>缺点: 输入字符包括$\epsilon$, 一个状态对于某个字符，可能有多条输出边</li></ul></li><li>NFA更贴近于人们对正规式的认识</li><li>DFA因为每次状态转换都是确定性的<h3 id="DFA的构建"><a href="#DFA的构建" class="headerlink" title="DFA的构建"></a>DFA的构建</h3></li></ol><ul><li>由自然语言描述构建<br>方法:  <ol><li>列出所有可能的状态</li><li>从各个状态出发, 构造边及输入字符记号</li></ol></li><li>由正规式构建 </li><li>由正规式创建NFA再构建<ol><li>NFA构建<br>NFA创建, 有如下框架:</li></ol></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_e.jpg" alt="nf_e.jpg"></td></tr><tr><td style="text-align:center">a</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_a.jpg" alt="nf_a.jpg"></td></tr><tr><td style="text-align:center">s   &#124;  t</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_s_t.jpg" alt="nf_s_t.jpg"></td></tr><tr><td style="text-align:center">st</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_st.jpg" alt="nf_st.jpg"></td></tr><tr><td style="text-align:center">s*</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_sp.jpg" alt="nf_sp.jpg"></td></tr></tbody></table></div><p>对于加括号的正规式(s), 使用N(s)作为其NFA<br>    举例:</p><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$\sf (a   &#124;  b)^{*}ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_example.jpg" alt></td></tr></tbody></table></div><ol><li>NFA转化为DFA(子集构造法)<ul><li>有限自动机理论: 设L为一个有不确定的有限自动机接受的集合，则存在一个接受L的确定的有限自动机</li><li>DFA的一个状态是NFA的一个状态集合, 即对于一个输入$a_1a_2…a_n$NFA可以到达所有状态为:$s_1, s_2, …, s_k$, 这些状态的集合为DFA的一个状态</li><li>如上述的$(a|b)^*ab$其NFA为<img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_example.jpg" alt><br>则对于各种输入, 有如下集合:</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">集合名称</th><th style="text-align:center">输入</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">$\epsilon$</td><td style="text-align:center">{0,1,2,4,7}</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">$a$</td><td style="text-align:center">{1,2,3,4,6,7,8}</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">$b$</td><td style="text-align:center">{1,2,4,5,6,7}</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">$b, a, b$</td><td style="text-align:center">{1,2,4,5,6,7,9}</td></tr></tbody></table></div><p>依据上表列出状态转换表:<br>    <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_ex_chart.jpg" alt><br>再画出转换图:<br>    <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_ex_p.jpg" alt></p><ol><li><p>DFA化简</p><ul><li><p>通常由上述方法得来的DFA并非最简的</p></li><li><p>状态的可区分性: 存在串w, 使得从状态s开始, 对w进行状态转换, 最终停在某个接受状态; 而对从t开始的状态转换停在了某个非接收状态<br><strong>简言之, 对于两个状态, 若其对于所有相同的输入转换后有相同的接受状态, 则其为不可区分的, 否则可区分 </strong><br>如上面的转换图 A与B可区分, A与C不可区分</p><ul><li>途径:<ul><li>根据状态是否可以区分，将状态划分成若干个集合，每个集合内的状态之间都不可区分，而任意两个集合中的元素都是可以互相区分的<ul><li>依据原始的DFA，在合并后的状态基础上，建立新的状态转换关系</li></ul></li></ul></li></ul></li><li><p>但是, 化简时DFA的状态转换函数必须是一个<strong>全函数</strong>(对于所有的输入都有对应的边，比如有a，b两个输入，那么每个状态必须有a，b两个出边，否则称之为部分函数)<br>部分函数需要添加<strong>死状态</strong>变成全函数，死状态即是添加一个状态，使所有缺失的边都指向它，它自己的所有输出边也指向本身，如下图<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/death.jpg" alt><br>加上了死状态E<br>但对于$\sf (a|b)^*ab$, 无需加死状态</p></li><li><p>化简$\sf (a|b)^*ab$<br>首先将接受状态和非接受状态分为两个部分<br>{A, B, C}, {D}<br>对于非接受状态，判断其转换函数<br>move({A, B, C}, a} = {B}结果还是非接受状态<br>move({A, B, C}, b} = {C, D}结果出现接受状态，而这种    改变是由于状态B造成，因此将B拆分出来<br>{A, C}, {B}, {D}<br>再重复以上过程<br>move({A, C}, a} = {B}<br>move({A, C}, b} = {C}<br>发现A，C不存在例外了<br>为格式化，我们将字母变成数字表示，将A,C合并<br>其中0代表A, C, 1代表B, 2代表D  </p></li><li>最终:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_fin.jpg" alt></li></ul></li></ol><h4 id="至此-词法分析完成"><a href="#至此-词法分析完成" class="headerlink" title="至此, 词法分析完成!"></a>至此, 词法分析完成!</h4><p>参考链接:</p><p> <a href="https://blog.csdn.net/zp_icenow/article/details/82661407" target="_blank" rel="noopener">https://blog.csdn.net/zp_icenow/article/details/82661407</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;词法分析器&quot;&gt;&lt;a href=&quot;#词法分析器&quot; class=&quot;headerlink&quot; title=&quot;词法分析器&quot;&gt;&lt;/a&gt;词法分析器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;词法分析器: 把构成源程序的字符流翻译成记号(token)流，还完成和用户接口的一些任务&lt;br&gt;  其中:&lt;ul&gt;
&lt;li&gt;词法单元: 亦称单词, 编程语言中合法的字符串&lt;/li&gt;
&lt;li&gt;词法记号: 满足某种给定规则(模式)的词法单元&lt;br&gt;示例: 对于词法记号NUM, 其词法单元可能有3.1, 10, 2.8E12等数字, 其”模式”即”认定为数字的字符串”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>How to Write an E-Mail</title>
    <link href="http://qidianxuan.github.io/2019/11/23/HowtoWriteAnE-Mail/"/>
    <id>http://qidianxuan.github.io/2019/11/23/HowtoWriteAnE-Mail/</id>
    <published>2019-11-23T07:09:39.000Z</published>
    <updated>2019-12-10T01:46:25.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Writing-an-Email-you-should"><a href="#Writing-an-Email-you-should" class="headerlink" title="Writing an Email you should:"></a>Writing an Email you should:</h1><ol><li>Use a Neutral Email Address</li><li>Use a short and accurate subject header</li><li>Use a proper salutation (formal)<ul><li>Title + Last name</li><li>Commonly used titles: ‘Mr.’ ,’Mrs.’,’Miss.’ …</li></ul></li><li>Introduce yourself in the First Paragraph if necessary (formal)</li><li>Write the actual message<ul><li>Do not indent</li><li>Insert a line break</li><li>No more than 5 paragraphs and No more than 5 sentences in each paragraph</li></ul></li><li>Use the correct form of leaving-taking</li><li>Sign properly</li><li>Proofread(校对) your email</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Writing-an-Email-you-should&quot;&gt;&lt;a href=&quot;#Writing-an-Email-you-should&quot; class=&quot;headerlink&quot; title=&quot;Writing an Email you should:&quot;&gt;&lt;/a&gt;Writ
      
    
    </summary>
    
    
      <category term="English" scheme="http://qidianxuan.github.io/categories/English/"/>
    
    
  </entry>
  
  <entry>
    <title>网络综合实验常用指令汇总</title>
    <link href="http://qidianxuan.github.io/2019/11/22/NetCmds/"/>
    <id>http://qidianxuan.github.io/2019/11/22/NetCmds/</id>
    <published>2019-11-22T09:50:02.000Z</published>
    <updated>2019-11-23T07:00:47.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>模拟器 : HCL</li><li>路由器 : MSR36-20</li><li>交换机 : S5820V2-54QS-GE</li><li>操作系统 : ComwareV7.0<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><h3 id="TELNET方式登录交换机"><a href="#TELNET方式登录交换机" class="headerlink" title="TELNET方式登录交换机"></a>TELNET方式登录交换机</h3>使用如下命令:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[SW]int vlan &#123;vlanid&#125;</span><br><span class="line">[SW-Vlan-interface1]ip address &#123;IP地址&#125; &#123;子网掩码&#125;</span><br><span class="line">[SW-Vlan-interface1]telnet server enable</span><br><span class="line">[SW]user-interface vty 0 4</span><br><span class="line">[SW-line-vty0-4]auth password</span><br><span class="line">[SW-line-vty0-4]set auth pass simple &#123;密码&#125;</span><br><span class="line">[SW-line-vty0-4]user level-3</span><br></pre></td></tr></table></figure>如上,之后在PC使用如下指令即可:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &#123;之前设置的ip地址&#125;</span><br></pre></td></tr></table></figure>如果使用交换机,记得设置交换机ip地址</li></ul><a id="more"></a><h3 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h3><p>首先,要新建立一个聚合组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SW]interface bridge-aggregation &#123;聚合端口号 0-1024&#125;</span><br></pre></td></tr></table></figure><br><br>注意 : 同一个聚合下的端口必须都工作在全双工模式下且速率相同<br><br>配置端口模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW-GigabitEthernet1/0/1]duplex &#123;工作模式: fall|half|auto&#125;</span><br><span class="line">[SW-GigabitEthernet1/0/1]speed &#123;速率: 10|100|1000|auto&#125;</span><br></pre></td></tr></table></figure><br>加入一个端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]interface Ethernet &#123;端口号,以1/0/1为例&#125;</span><br><span class="line">[SW-GigabitEthernet1/0/1]port link-aggregation &#123;聚合端口号&#125;</span><br></pre></td></tr></table></figure><br>如上,端口 1/0/1 被 聚合 到 组2 内,之后,可以看一下结果<br><br>显示聚合信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SW]display link-aggregation summary</span><br></pre></td></tr></table></figure></p><h3 id="生成树协议配置"><a href="#生成树协议配置" class="headerlink" title="生成树协议配置"></a>生成树协议配置</h3><p>首先,为了使各交换机使用相同的生成树协议标准,先在个交换机执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]stp mode rstp</span><br><span class="line">[SW]stp patchcost-standard legacy</span><br></pre></td></tr></table></figure><br>因为STP默认开启,所以此时STP已打开</p><h3 id="VLAN配置"><a href="#VLAN配置" class="headerlink" title="VLAN配置"></a>VLAN配置</h3><p>创建vlan将端口加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]vlan &#123;vlan id&#125;</span><br><span class="line">[SW-vlan2]prot GigabitEthernet &#123;起始端口号&#125; to &#123;终止端口号&#125;</span><br></pre></td></tr></table></figure><br>注意 : 也可以只写一个port来加入,这样创建的port类型为缺省值access port<br>要建立trunk port,需要首先对目标端口进行链路聚合(哪怕只有一个端口)<br>之后,进行如下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW-bridge-aggregation1]port link-type trunk</span><br><span class="line">[SW-bridge-aggregation1]port trunk permit vlan &#123;源Vlan id&#125; to &#123;目标vlan id&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="使用TELNET登录路由器"><a href="#使用TELNET登录路由器" class="headerlink" title="使用TELNET登录路由器"></a>使用TELNET登录路由器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RT]telnet server enable  /缺省情况下，Telnet服务处于关闭状态</span><br><span class="line">[RT]line vty 0   /进入一个或多个VTY用户线视图</span><br><span class="line">[RT-line-vty0]authentication-mode scheme  /设置登录用户的认证方式为通过AAA认证</span><br><span class="line">[RT]local-user test class manage（创建用户名）</span><br><span class="line">[RT-luser-manage-test]password simple &#123;密码&#125;</span><br><span class="line">[RT-luser-manage-test]service-type telnet</span><br><span class="line">[RT-luser-manage-test]authorization-attribute user-role network-admin（设置登陆权限是超级用户最高权限）</span><br></pre></td></tr></table></figure><h3 id="路由协议设置"><a href="#路由协议设置" class="headerlink" title="路由协议设置"></a>路由协议设置</h3><p>静态路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static &#123;dest ip addr&#125; &#123;mask&#125; &#123;next-hoop&#125;</span><br></pre></td></tr></table></figure><br>显示路由表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsiplay ip routing-table</span><br></pre></td></tr></table></figure><br>rip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[RT]rip</span><br><span class="line">[RT-rip1]network &#123;指定网段地址&#125; &#123;反子网掩码&#125;</span><br></pre></td></tr></table></figure><br>注意:需要添加所有需要的网段地址,包括自己</p><p><br><br>ospf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]ospf</span><br><span class="line">[RT-ospf-1]area 0</span><br><span class="line">[RT-ospf-1-area-0.0.0.0]network &#123;要启用的ip&#125; &#123;反子网掩码&#125;</span><br></pre></td></tr></table></figure><h3 id="广域网协议设置"><a href="#广域网协议设置" class="headerlink" title="广域网协议设置"></a>广域网协议设置</h3><h4 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h4><p><br>pap为双向认证,需要双方都开启<br><br><br><br>验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp authentication-mode pap</span><br><span class="line">[RA]local-user &#123;用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure><br>被验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RB-Serial1/0]ppp pap local-user &#123;用户名&#125; password simple &#123;密码&#125;</span><br></pre></td></tr></table></figure><br>注意:此处用户名与密码须与上述相同<br><br>此时只实现了单向验证,双方是无法ping通的,需要实现双向认证</p><h4 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h4><p><br>验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp authentication-mode chap</span><br><span class="line">[RA-Serial1/0]ppp chap user &#123;对方用户名&#125;</span><br><span class="line">[RA]local-user &#123;自己用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure><br>被验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp chap user &#123;对方用户名&#125;</span><br><span class="line">[RA]local-user &#123;自己用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>基于basic ACL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]acl basic &#123;acl编号2000~&#125; match-order auto</span><br><span class="line">[RT-acl-inv4-adv-2001]rule &#123;permit|deny&#125; ip &#123;source|dest&#125; &#123;反子网掩码&#125;</span><br><span class="line">[RT-Eth/Ser]packet-filter 2001 &#123;inbound|outbound&#125;</span><br></pre></td></tr></table></figure><br>基于advanced ACL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]acl advanced &#123;acl编号3000~&#125; match-order auto</span><br><span class="line">[RT-acl-inv4-adv-3001]rule &#123;permit|deny&#125; ip source &#123;源ip地址|any&#125; &#123;反掩码|前为any时不写&#125; destination &#123;目的ip地址|any&#125; &#123;反掩码|前为any时不写&#125;</span><br><span class="line">[RT-Eth/Ser] packet-filter 3001 &#123;inbound|outbound&#125;</span><br></pre></td></tr></table></figure></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>首先要建立地址池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[RT]nat address-group &#123;id&#125; </span><br><span class="line">[RT-address-group-1]address &#123;被映射ip组&#125; &#123;目标映射IP组&#125;</span><br></pre></td></tr></table></figure><br>同时要建立acl,如防火墙<br><br>最后,应用在端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RT-Serial1/0]nat outbound &#123;acl id&#125; address-group &#123;group id&#125;</span><br></pre></td></tr></table></figure><br>另外,对于具体到某个端口的nat映射,有如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RT-Serial1/0]nat server protocol tcp global &#123;映射ip&#125; &#123;映射端口号&#125; inside &#123;被映射的ip&#125; &#123;被映射端口号&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验设备&quot;&gt;&lt;a href=&quot;#实验设备&quot; class=&quot;headerlink&quot; title=&quot;实验设备&quot;&gt;&lt;/a&gt;实验设备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;模拟器 : HCL&lt;/li&gt;
&lt;li&gt;路由器 : MSR36-20&lt;/li&gt;
&lt;li&gt;交换机 : S5820V2-54QS-GE&lt;/li&gt;
&lt;li&gt;操作系统 : ComwareV7.0&lt;h2 id=&quot;交换机&quot;&gt;&lt;a href=&quot;#交换机&quot; class=&quot;headerlink&quot; title=&quot;交换机&quot;&gt;&lt;/a&gt;交换机&lt;/h2&gt;&lt;h3 id=&quot;TELNET方式登录交换机&quot;&gt;&lt;a href=&quot;#TELNET方式登录交换机&quot; class=&quot;headerlink&quot; title=&quot;TELNET方式登录交换机&quot;&gt;&lt;/a&gt;TELNET方式登录交换机&lt;/h3&gt;使用如下命令:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[SW]int vlan &amp;#123;vlanid&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW-Vlan-interface1]ip address &amp;#123;IP地址&amp;#125; &amp;#123;子网掩码&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW-Vlan-interface1]telnet server enable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW]user-interface vty 0 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW-line-vty0-4]auth password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW-line-vty0-4]set auth pass simple &amp;#123;密码&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[SW-line-vty0-4]user level-3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
如上,之后在PC使用如下指令即可:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;telnet &amp;#123;之前设置的ip地址&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
如果使用交换机,记得设置交换机ip地址&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://qidianxuan.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
