<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qidianxuan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qidianxuan.github.io/"/>
  <updated>2019-12-09T12:14:04.885Z</updated>
  <id>http://qidianxuan.github.io/</id>
  
  <author>
    <name>qidianxuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编译原理-文法分析-自下而上分析</title>
    <link href="http://qidianxuan.github.io/2019/12/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/12/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/</id>
    <published>2019-12-08T08:28:50.000Z</published>
    <updated>2019-12-09T12:14:04.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="规约-对应最右推导的逆过程"><a href="#规约-对应最右推导的逆过程" class="headerlink" title="规约: 对应最右推导的逆过程"></a>规约: 对应最右推导的逆过程</h3><h3 id="句柄-和某产生式右部匹配的子串"><a href="#句柄-和某产生式右部匹配的子串" class="headerlink" title="句柄: 和某产生式右部匹配的子串"></a>句柄: 和某产生式右部匹配的子串</h3><ul><li>句柄是句型的一个字串</li><li>把句柄<strong>规约</strong>为非终结符代表了某一步最右推导的逆过程</li><li>句柄的右边只有终结符</li><li>若文法二义, 则句柄不唯一<h2 id="移进-规约分析"><a href="#移进-规约分析" class="headerlink" title="移进-规约分析"></a>移进-规约分析</h2></li><li>输入: 以$结尾的句子</li><li>栈: 栈底为$的栈</li><li>分析表: 确定下一步动作为移进还是规约</li><li>分析程序<ul><li>四种动作<ul><li>移进: 下一个输入符号压栈</li><li>规约: 确定使用那个产生式</li><li>接受: 输出分析成功</li><li>报错: 发生语法错误, 调用错误恢复例程</li></ul></li><li>对于每个字符, 若可规约则规约, 不可规约则继续移进判断可否规约(查表)</li></ul></li><li>移进-规约分析的冲突<ul><li>要移进还是规约?</li></ul></li><li>规约-规约冲突<ul><li>选择那个产生式进行规约?</li></ul></li></ul><h2 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h2><p>LR分析器处理LR(k)文法</p><ul><li>k指决定分析动作时向前看的符号个数, k=1时省略</li><li>LR分析器采用LR分析方法</li><li>特点:<ul><li>适用于上下文无关文法</li><li>效率高</li></ul></li><li>三种技术<ul><li>简单的LR方法, 简称SLR</li><li>规范的LR方法</li><li>向前看的LR方法, 简称LALR</li></ul></li><li>格局(Configuration)<ul><li>二元组 $(s_0X_1s_1X_2…X_ms_m, a_ia_{i+1}…a_n\$) $</li><li>作为栈的内容, 右边为未处理的串</li><li>$ X_i$ 为文法符号, $s_i$为状态</li><li>在某个时刻, 该格局的状态总为右句型$ X_1X_2…X_ma_ia_{i+1}…a_n $</li></ul></li><li>结构:<ul><li>输入: 以$结尾的句子</li><li>栈: 元素为符号和状态 </li><li>LR分析表Action[s,a]和Goto[s,A]</li></ul></li><li>算法:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = w$的第一个符号, w为句子;</span><br><span class="line">栈顶此时为s0</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s = 栈顶状态;</span><br><span class="line">    <span class="keyword">if</span>(Action[s,a]==移进状态t)&#123;</span><br><span class="line">        把a和t依次压入栈;</span><br><span class="line">        a = 下一个输入符号;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Action[s,a]==规约A-&gt;b)&#123;</span><br><span class="line">        栈顶退掉<span class="number">2</span>*|b|个符号, |b|为b的长度</span><br><span class="line">        t = 栈顶状态;</span><br><span class="line">        A和<span class="keyword">goto</span>[t,A]压入栈;</span><br><span class="line">        输出(打印)产生式A-&gt;b</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Action[s,a]==接受)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        调用错误恢复例程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>右句型的前缀, 该前缀不超过最右句柄的右端</p><ul><li>右句型: 进行最右推导时形成的句型</li><li>前缀: 一个符号串的前缀是指从第一个符号开始的连续若干符号构成的字串(可以为空)</li><li>定义:<br>对于推导S ⟹ <em>$_{rm}$Aw ⟹ $_{rm}$ybw<br>yb的任何前缀(包括ε和yb本身)都是一个活前缀<br>简单的来说, 即<em>*分析栈里面出现的串</em></em><h4 id="活前缀与句柄的关系"><a href="#活前缀与句柄的关系" class="headerlink" title="活前缀与句柄的关系"></a>活前缀与句柄的关系</h4></li><li>活前缀已经含有句柄的全部符号, 则证明产生式A⟶β的右部β已经出现在栈顶</li><li>活前缀只含有句柄的一部分符号,如对A⟶β1β2, 若活前缀只含一部分符号β1,则说明β1已经出现在栈顶, 当前期待看到从β2推出的符号</li><li>活前缀不含句柄任何符号, 则期望产生式A⟶β右部推出的符号串<h3 id="SLR"><a href="#SLR" class="headerlink" title="SLR"></a>SLR</h3><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h4>在右部的某个地方加点的产生式<br>  如对A ⟶ XYZ, 有A ⟶ ·XYZ 或A ⟶ X·YZ等<br>  对于A ⟶ ε, 有A ⟶ ·<br>  点的左边表示已经看到的部分, 右边为期望的部分<h4 id="LR-0-项目集"><a href="#LR-0-项目集" class="headerlink" title="LR(0)项目集"></a>LR(0)项目集</h4>若干个LR(0)项目的集合<h4 id="从文法构造识别活前缀的DFA"><a href="#从文法构造识别活前缀的DFA" class="headerlink" title="从文法构造识别活前缀的DFA"></a>从文法构造识别活前缀的DFA</h4></li><li>拓广文法<br>考虑文法:  </li></ul><blockquote><p>$ E \rightarrow E + T | T $<br>$ T \rightarrow T * F | F $<br>$ F \rightarrow (E) | id $  </p></blockquote><p>无法判断其起始符号, 因为起始符号E出现在了产生式右端<br>所以加入如下产生式:  </p><blockquote><p>$ E’ \rightarrow E $  </p></blockquote><p>使得起始符号位E’, 这样的文法为<strong>拓广文法</strong></p><ul><li><p>构建LR(0)项目集的规范族<br>  依然考虑上述文法</p><ul><li>闭包函数closure(I)<ol><li>I的每个项目均加入closure(I)中</li><li>如果A ⟶ α·Bβ在closure(I)中,且B ⟶ ·γ还不在closure(I))中的话,则将其加入(α,β可为空)</li></ol></li></ul><ol><li>首先由构造状态$I_0$, 由E’ ⟶ E生成, 应包括其所有闭包<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/I0_.jpg" alt=""></li><li><p>再观察状态$I_0$可能碰到的符号, 计算$I_1$:=goto($I_0$,X), 即满足[A ⟶ α·Xβ]的属于$I_0$的所有项目[A ⟶ αX·β]的<strong>闭包</strong><br>如下图$I_1$为$I_0$碰到E时的情况<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/I1.jpg" alt=""></p></li><li><p>考虑所有的情况,写作$I_x$,并作出DFA:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Ifin.jpg" alt=""></p></li><li><p>从DFA构造SLR分析表<br>对于状态i从$I_i$构造, 它的action函数如下确定:</p></li></ol><ul><li>若[A ⟶ α·aβ]在$I_i$中, 并且goto($I_i$,a)=$I_j$, 那么置action[i,a]为sj</li><li>若[A ⟶ α·]在$I_i$中, 那么对FOLLOW(A)中的所有a, 置action[i,a]为rj, j是产生式A ⟶ α的编号</li><li>若[S’ ⟶ S·]在$I_i$中, 那么置action[i,$]为接受状态acc<br>对于状态i的goto函数  </li><li>对所有的非终结符A, 如果goto($I_i$,A)=$I_j$, 那么goto[i,A]=j<br>其余为ERROR, 出现冲突则该文法并非SLR(1)  </li></ul></li></ul><pre><code>    &gt; 以E ⟶ T·, T ⟶ T·\*F为例      &gt; FOLLOW(E)={\$,+,)},则action[2,$]=action[2,+]=action[2,)]=r2     &gt; action[2,*]=s7</code></pre><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><ul><li>SLR文法描述能力有限<h4 id="前向搜索符"><a href="#前向搜索符" class="headerlink" title="前向搜索符"></a>前向搜索符</h4></li><li>对于一个项目 A ⟶ α·β, 如果最终利用这个产生式进行规约之后, 希望看到的符号为a, 则该项目的前向搜索符为a</li><li>则上述项目写为A ⟶ α·β, a<h4 id="LR-1-项目"><a href="#LR-1-项目" class="headerlink" title="LR(1)项目"></a>LR(1)项目</h4></li><li>带上搜索符的LR(0)项目</li><li>LR(1)项目[A ⟶ α·β, a]对活前缀γ<strong>有效</strong>:<ul><li>如果存在推导S ⟹ *$_{rm}$δAω ⟹ $_{rm}$δαβω, 其中γ = δα, a是ω的第一个符号, 或者ω是ε且a是$(即β后只能跟a或\$)</li></ul></li><li>对于项目[A ⟶ α·β, a]<ul><li>当β不为空时, 采取移进操作</li><li>当β为空时, 根据搜索符a而并非A后继符FOLLOW(A)来进行规约(区别于LR(0)), 通常a的集合为FOLLOW(A)的子集</li></ul></li><li>项目集计算闭包函数closure(I)<ul><li>I中的任何项目都属于closure(I)</li><li>若有项目[A ⟶ α·Bβ, a]在closure(I)中, 而B ⟶ γ是文法中的产生式, b是FIRST(βa)中的元素, 则[B ⟶ ·γ,b]也属于closure(I)</li></ul></li><li><p>考虑文法</p><blockquote><p>S’ ⟶ S<br>S ⟶ BB<br>B ⟶ bB<br>B ⟶ a</p></blockquote><p>  参照SLR的方法构建状态转换图:<br>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LR(1" alt="">.jpg)</p></li><li><p>构造分析表:<br>从$I_i$构造分析器的状态i, 器action函数如下确定:  </p><ul><li>如果[A ⟶ α·aβ, b]在$I_i$中, 且goto($I_i$,a)=$I_j$, 那么置action[i,a]为sj</li><li>如果[A ⟶ a·, a]在$I_i$中, 且A ≠ S’, 那么置action[i,a]为rj</li><li><p>如果[S’ ⟶ S·, $]在$I_i$中, 那么置action[i,$]为acc</p><p>状态i的goto函数如下确定:</p></li><li>若goto($I_i$,A) = $I_j$, 那么goto[i,A] = j<br>初始状态为[S’ ⟶ S, $], 上述未定义为error</li></ul></li></ul><h3 id="LALR"><a href="#LALR" class="headerlink" title="LALR"></a>LALR</h3><p>LR状态表数目较多</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ul><li>合并LR(1)文法的活前缀的DFA中的同心项目集<ul><li>同心的LR(1)项目集:<ul><li>略去搜索符后他们是相同的集合</li></ul></li></ul></li></ul><p>合并前:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LALRA.jpg" alt=""><br>合并后:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/LALRB.jpg" alt=""></p><h4 id="合并后可能引起的冲突"><a href="#合并后可能引起的冲突" class="headerlink" title="合并后可能引起的冲突"></a>合并后可能引起的冲突</h4><ul><li>不会引起新的移进-规约冲突</li><li>有可能引起新的规约-规约冲突</li></ul><h4 id="按构造LR-1-分析表的方式进行构造分析表"><a href="#按构造LR-1-分析表的方式进行构造分析表" class="headerlink" title="按构造LR(1)分析表的方式进行构造分析表"></a>按构造LR(1)分析表的方式进行构造分析表</h4><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="LR-1"><a href="#LR-1" class="headerlink" title="LR"></a>LR</h3><ol><li>栈中的文法总是一个活前缀</li><li>分析表的转移函数实际上是识别活前缀的DFA</li><li>栈顶的状态符号包含了确定句柄所需要的一切信息</li><li>最一般的无回溯的移进-规约方法</li><li>能分析的文法类是预测分析法能分析的文法类的真超集</li><li>能及时发现错误<br> 但手工构造分析表工作量太大!<h3 id="比较表格"><a href="#比较表格" class="headerlink" title="比较表格"></a>比较表格</h3></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">LR(1)</th><th style="text-align:center">LL(1)</th></tr></thead><tbody><tr><td style="text-align:center">建立分析树的方式</td><td style="text-align:center">自上而下</td><td style="text-align:center">自下而上</td></tr><tr><td style="text-align:center">规约还是推导</td><td style="text-align:center">规范规约</td><td style="text-align:center">最左推导</td></tr><tr><td style="text-align:center">决定使用产生式的时机</td><td style="text-align:center">看见产生式整个右部推出的东西才规约</td><td style="text-align:center">看见产生式右部推出的第一个终结符就进行推导</td></tr><tr><td style="text-align:center">对文法的显式限制</td><td style="text-align:center">没有</td><td style="text-align:center">无左递归,无公共左因子</td></tr><tr><td style="text-align:center">分析表比较</td><td style="text-align:center">状态×文法符号导致分析表大</td><td style="text-align:center">非终结符×终结符,分析表小</td></tr><tr><td style="text-align:center">栈比较</td><td style="text-align:center">状态栈</td><td style="text-align:center">文法符号栈</td></tr><tr><td style="text-align:center">确定句柄</td><td style="text-align:center">根据栈顶状态和下一个符号便可以确定句柄及规约用产生式</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">语法错误</td><td style="text-align:center">出现则报错</td><td style="text-align:center">出现则报错</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;规约-对应最右推导的逆过程&quot;&gt;&lt;a href=&quot;#规约-对应最右推导的逆过程&quot; class=&quot;headerlink&quot; title=&quot;规约: 对应最右推导的逆过程&quot;&gt;&lt;/a&gt;规约: 对应最右推导的逆过程&lt;/h3&gt;&lt;h3 id=&quot;句柄-和某产生式右部匹配的子串&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>复制特殊字符到剪切板</title>
    <link href="http://qidianxuan.github.io/2019/11/30/%E5%A4%8D%E5%88%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    <id>http://qidianxuan.github.io/2019/11/30/%E5%A4%8D%E5%88%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</id>
    <published>2019-11-30T09:10:33.000Z</published>
    <updated>2019-11-30T09:58:14.202Z</updated>
    
    <content type="html"><![CDATA[<html>    <head>        <meta charset="utf-8">        <title>复制特殊字符</title>        <style>            .button{                display: inline-block;                border-radius: 4px;                background-color: #66CCFF;                border: none;                color: #FFFFFF;                text-align: center;                font-size: 22px;                padding: 10px;                width: 100px;                transition: all 0.5s;                cursor: pointer;                margin: 5px;            }            .button span {                cursor: pointer;                display: inline-block;                position: relative;                transition: 0.5s;            }            .button span:after {                content: '»';                position: absolute;                opacity: 0;                top: 0;                right: -20px;                transition: 0.5s;            }            .button:hover span {                padding-right: 25px;            }            .button:hover span:after {                 opacity: 1;                right: 0;            }            body{                font-family: dengxian;            }            p{                font-size: 18px;            }        </style>        <script>            function copyText(text){                var input = document.getElementById("input");                input.value = text;                input.select();                document.execCommand("copy");                alert("复制 "+text+" 成功");            }         </script>    <link rel="alternate" href="/atom.xml" title="qidianxuan's blog" type="application/atom+xml"></head>    <body>        <div id="container">          <textarea id="input" style="width:99%;height: 1%;"></textarea>            <div id="arrow" style="width: auto;height:auto;">                <p style="font:dengxian">箭头</p>                <button class="button" style="vertical-align: middle" onclick="copyText('⟶')"><span>⟶</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟵')"><span>⟵</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟹')"><span>⟹</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⟸')"><span>⟸</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇒')"><span>⇒</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇐')"><span>⇐</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇑')"><span>⇑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⇓')"><span>⇓</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('→')"><span>→</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('←')"><span>←</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('↑')"><span>↑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('↓')"><span>↓</span></button>            </div>            <div id="set" style="width: auto;height:auto;">                <p style="width: 110px;">集合运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∅')"><span>∅</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∈')"><span>∈</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∉')"><span>∉</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊂')"><span>⊂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊃')"><span>⊃</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊆')"><span>⊆</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊇')"><span>⊇</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋂')"><span>⋂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋃')"><span>⋃</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋁')"><span>⋁</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋀')"><span>⋀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨄')"><span>⨄</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨆')"><span>⨆</span></button>            </div>            <div id="math" style="width: auto;height:auto;">                <p style="width: 110px;">数学运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('±')"><span>±</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('×')"><span>×</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('÷')"><span>÷</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∣')"><span>∣</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∑')"><span>∑</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∏')"><span>∏</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≈')"><span>≈</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≡')"><span>≡</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≠')"><span>≠</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≤')"><span>≤</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('≥')"><span>≥</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⋅')"><span>⋅</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∘')"><span>∘</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨀')"><span>⨀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨂')"><span>⨂</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⨁')"><span>⨁</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('⊥')"><span>⊥</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∠')"><span>∠</span></button>            </div>            <div id="integral" style="width: auto;height:auto;">                <p style="width: 110px;">积分运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∫')"><span>∫</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∬')"><span>∬</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∭')"><span>∭</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∮')"><span>∮</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∞')"><span>∞</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∇')"><span>∇</span></button>            </div>            <div id="logic" style="width: auto;height:auto;">                <p style="width: 110px;">逻辑运算</p>                <button class="button" style="vertical-align: middle" onclick="copyText('∵')"><span>∵</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∴')"><span>∴</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∀')"><span>∀</span></button>                <button class="button" style="vertical-align: middle" onclick="copyText('∃')"><span>∃</span></button>            </div>        </div>    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;复制特殊字符&lt;/title&gt;
        &lt;style&gt;
            .button{
                display:
      
    
    </summary>
    
    
      <category term="小工具" scheme="http://qidianxuan.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-文法分析-自上而下分析</title>
    <link href="http://qidianxuan.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/</id>
    <published>2019-11-29T07:14:29.000Z</published>
    <updated>2019-12-08T08:29:15.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h2><p>利用一般方法, 有可能不能处理左递归, 考虑如下例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E ⟶ E + T | T</span><br><span class="line">T ⟶ T * F | F</span><br><span class="line">F ⟶ ( E ) | id</span><br></pre></td></tr></table></figure><br>存在如下分析树:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Compile3-1.jpg" alt=""><br>分析树无法做出, 存在无限递归  </p><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p>先定义两个函数:</p><h3 id="FIRST集"><a href="#FIRST集" class="headerlink" title="FIRST集"></a>FIRST集</h3><ul><li><p>FIRST(α) = {a | α ⇒ * a…, a $\sf\in V_T$}  </p><ul><li>FIRST(α)是从α推导出的串的起始终结符的集合    </li><li>特别的是: α ⇒ *ε 时, 规定 ε $\sf\in$ FIRST(α)</li><li>对于A的任何两个选择$\alpha_i$和$\alpha_j$, 希望有FIRST($\alpha_i$)⋂FIRST($\alpha_j$) = ∅<br>但是需要FIRST($\alpha_i$)和FIRST($\alpha_j$)都不含ε</li><li><p>FIRST集合计算方法:</p><ul><li>若X⟶a… 则将终结符a加入FIRST(X)中</li><li>若X⟶ε, 则将ε加入FIRST(X)中</li><li>若X⟶Y…, 且Y为非终结符, 则将FIRST(Y)去除{ε}后加入FIRST(X)中</li><li>若X⟶Y_1Y_2..Y_K,且Y1,Y2,..Yi-1 (2≤i≤k)都是非终结符，且Y1,Y2,..Yi-1 的FIRST集合中均包含ε，则将FIRST(Yj)的所有非ε元素加入到FIRST(X)中，(j=1,2,..i).特别地，若Y1~YK均有ε产生式，则将ε加到FIRST(X)中</li><li><p>例子:</p><pre><code>  S ⟶ BA  A ⟶ BS|d  B ⟶ aA|bS|c  则  FIRST(S) = FIRST(B)   FIRST(A) = FIRST(B) ⋃ {d}  FIRST(B) = {a,b,c}</code></pre></li></ul></li></ul></li></ul><h3 id="FOLLOW集"><a href="#FOLLOW集" class="headerlink" title="FOLLOW集"></a>FOLLOW集</h3><ul><li><p>FOLLOW(A) = {a | S ⇒ * …Aa…, a $\sf\in V_T$}  </p><ul><li>如果A是某个句型的最右符号(如S⇒*αA), 那么$(结束标记)属于FOLLOW(A)</li><li><p>FOLLOW集合计算方法</p><ol><li>对文法开始符号S,置$于FOLLOW(S)中</li><li>若有A⟶αBβ, 则将<strong>FIRST</strong>(β)去除{ε}后加入FOLLOW(B)中. (此处α可以为空)</li><li>若A⟶αB 或A⟶αBβ, 且β ⇒* ε(ε属于FIRST(β)), 则将FOLLOW(A)加入FOLLOW(B)中. (此处α可以为空）</li></ol><ul><li><p>例子:</p><pre><code>  S ⟶ BA  A ⟶ BS|d  B ⟶ aA|bS|c  则  第一步(加入$):   由S为开始符, FOLLOW(S) += {$}  此时FOLLOW(S) = {$}  第二步(加入FIRST集合):   由S ⟶ BA, FOLLOW(B) += FIRST(A)  由A ⟶ BS|d, FOLLOW(B) += FIRST(S)  此时FOLLOW(B) = {a,b,c,d}  第三步(判断可加入的FOLLOW集合):  由B ⟶ aA|bS|c  既由B ⟶ aA, 得FOLLOW(A) +=  FIRST(B)  由B ⟶ bS, 得FOLLOW(S) += FIRST(B)  此时FOLLOW(S) = {a,b,c,d,$}, FOLLOW(A) = {a,b,c,d}  再由S ⟶ BA, FOLLOW(A) += FOLLOW(S)  此时FOLLOW(A) = {a,b,c,d,$}  以上</code></pre></li></ul></li></ul></li></ul><h3 id="LL-1-文法-1"><a href="#LL-1-文法-1" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>任意两个产生式A ⟶ α|β 如果他们都满足</p><ul><li>FIRST(α) ⋂ FIRST(β) = ∅</li><li>若β ⇒ *ε , 那么FIRST(α) ⋂ FOLLOW(A) = ∅</li></ul><p>对于LL(1)文法, 有一些明显的性质:</p><ul><li>没有公共左因子</li><li>不是二义的</li><li>不含左递归</li></ul><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">E ⟶ TE<span class="number">'</span></span><br><span class="line">E<span class="number">'</span>⟶ +TE<span class="number">'</span>|ε</span><br><span class="line">T ⟶ FT<span class="number">'</span></span><br><span class="line">T<span class="number">'</span>⟶ *FT<span class="number">'</span>|ε</span><br><span class="line">F ⟶ (E)|id</span><br><span class="line">该文法是LL(<span class="number">1</span>)文法吗?</span><br><span class="line"><span class="number">1.</span> 先求出FIRST集合</span><br><span class="line">FIRST(E) = &#123;(,id&#125;</span><br><span class="line">FIRST(T) = &#123;(,id&#125;</span><br><span class="line">FIRST(F) = &#123;(,id&#125;</span><br><span class="line">FIRST(E<span class="number">'</span>) = &#123;+,ε&#125;</span><br><span class="line">FIRST(T<span class="number">'</span>) = &#123;*,ε&#125;</span><br><span class="line"><span class="number">2.</span> 求各FOLLOW集合</span><br><span class="line">由规则<span class="number">1</span>:</span><br><span class="line">E为起始符, 则FOLLOW(E) += &#123;$&#125;</span><br><span class="line">由规则<span class="number">2</span>:</span><br><span class="line">由F ⟶ (E), 得FOLLOW(E) += &#123;)&#125; 此时FOLLOW(E) = &#123;),$&#125;</span><br><span class="line">由E ⟶ TE<span class="number">'</span>, 得FOLLOW(T) += FIRST(E<span class="number">'</span>) 此时FOLLOW(T) = &#123;+,),$&#125; </span><br><span class="line">由T ⟶ FT<span class="number">'</span>, 得FOLLOW(F) += FIRST(T<span class="number">'</span>) 此时FOLLOW(F) = &#123;*,),$&#125;</span><br><span class="line">由规则<span class="number">3</span>:</span><br><span class="line">由E ⟶ TE<span class="number">'</span>, 得FOLLOW(T) += FOLLOW(E) 此时FOLLOW(T) = &#123;+,),$&#125; </span><br><span class="line">由T ⟶ FT<span class="number">'</span>, 得FOLLOW(F) += FOLLOW(T) 此时FOLLOW(F) = &#123;+,*,),$&#125;</span><br><span class="line">再有:</span><br><span class="line">FOLLOW(E<span class="number">'</span>) = FOLLOW(E)</span><br><span class="line">FOLLOW(T<span class="number">'</span>) = FOLLOW(T)</span><br><span class="line"><span class="number">3.</span> 判断</span><br><span class="line">对于E<span class="number">'</span>⟶ +TE<span class="number">'</span>|ε</span><br><span class="line">FIRST(+TE<span class="number">'</span>) = &#123;+&#125;</span><br><span class="line">FOLLOW(E<span class="number">'</span>) = &#123;),$&#125;</span><br><span class="line">FIRST(+TE<span class="number">'</span>) ⋂ FOLLOW(E<span class="number">'</span>) = ∅</span><br><span class="line">对于T<span class="number">'</span>⟶ *FT<span class="number">'</span>|ε</span><br><span class="line">FIRST(*FT<span class="number">'</span>) = &#123;*&#125;</span><br><span class="line">FOLLOW(T<span class="number">'</span>) = &#123;+,),$&#125;</span><br><span class="line">FIRST(*FT<span class="number">'</span>) ⋂ FOLLOW(T<span class="number">'</span>) = ∅</span><br><span class="line">该文法为LL(<span class="number">1</span>)文法</span><br></pre></td></tr></table></figure><h2 id="自上而下分析实现"><a href="#自上而下分析实现" class="headerlink" title="自上而下分析实现"></a>自上而下分析实现</h2><h3 id="递归函数法"><a href="#递归函数法" class="headerlink" title="递归函数法"></a>递归函数法</h3><ul><li>为每个非终结符都写一个分析过程</li><li>过程可能存在递归<br>举例:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于文法</span></span><br><span class="line"><span class="comment">S ⟶ BA</span></span><br><span class="line"><span class="comment">A ⟶ BS|d</span></span><br><span class="line"><span class="comment">B ⟶ aA|bS|c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">需要实现如下函数</span><br><span class="line">S()&#123;</span><br><span class="line">    B();</span><br><span class="line">    A();</span><br><span class="line">&#125;</span><br><span class="line">A()&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead==<span class="string">'a'</span>|<span class="string">'b'</span>|<span class="string">'c'</span>)&#123;</span><br><span class="line">        B();</span><br><span class="line">        S();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'d'</span>)</span><br><span class="line">        match(<span class="string">'d'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead==<span class="string">'a'</span>)&#123;</span><br><span class="line">        match(<span class="string">'a'</span>);</span><br><span class="line">        A();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'b'</span>)&#123;</span><br><span class="line">        match(<span class="string">'b'</span>);</span><br><span class="line">        S();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lookahead==<span class="string">'c'</span>)</span><br><span class="line">        match(<span class="string">'c'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br><span class="line">match(<span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span>(lookahead == c)</span><br><span class="line">        lookahead = nextToken();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归的预测分析法"><a href="#非递归的预测分析法" class="headerlink" title="非递归的预测分析法"></a>非递归的预测分析法</h3><ul><li><p>构造预测分析表, 按照如下流程图:<br>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/Chartmake.png" alt=""><br>  举例:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">文法:</span><br><span class="line">S ⟶ ACD</span><br><span class="line">A ⟶ a|ε</span><br><span class="line">C ⟶ c</span><br><span class="line">D ⟶ d</span><br><span class="line">其FIRST集合:</span><br><span class="line">FIRST(S) = &#123;a, c&#125;</span><br><span class="line">FIRST(A) = &#123;a, ε&#125;</span><br><span class="line">FIRST(C) = &#123;c&#125;</span><br><span class="line">FIRST(D) = &#123;d&#125;</span><br><span class="line">其FOLLOW集合:</span><br><span class="line">FOLLOW(S) = &#123;$&#125;</span><br><span class="line">FOLLOW(A) = &#123;c&#125;</span><br><span class="line">FOLLOW(C) = &#123;d&#125;</span><br><span class="line">FOLLOW(D) = &#123;$&#125;</span><br><span class="line">则其预测分析表为</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/ChartExam.jpg" alt=""></p><ul><li>若文法为二义的, 将会出现一格内有两项的问题.</li><li>算法实现:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入: 串w和文法G的分析表M</span></span><br><span class="line"><span class="comment">//输出: 是否符合文法, 符合则输出w的左推导</span></span><br><span class="line"></span><br><span class="line">ip = w$的第一个符号</span><br><span class="line">X = 栈顶元素</span><br><span class="line"><span class="keyword">while</span>(X!=$)&#123;</span><br><span class="line">    <span class="keyword">if</span> (X为a) 把X弹出并把ip推向下一个符号</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X为终结符)</span><br><span class="line">        把X从栈顶弹出, ip入栈, ip指向下一个符号</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为ERROR)</span><br><span class="line">        error();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为X ⟶ Y1Y2...Yk)&#123;</span><br><span class="line">        输出产生式;</span><br><span class="line">        栈中弹出X;</span><br><span class="line">        把Yk...Y2Y1依次压入栈, Y1在栈顶</span><br><span class="line">    &#125; </span><br><span class="line">    令X为栈顶元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>分析举例: 对输入 id * id + id</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提:&quot;&gt;&lt;/a&gt;前提:&lt;/h2&gt;&lt;p&gt;利用一般方法, 有可能不能处理左递归, 考虑如下例子&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Tips of an Interview</title>
    <link href="http://qidianxuan.github.io/2019/11/27/Tips-of-an-Interview/"/>
    <id>http://qidianxuan.github.io/2019/11/27/Tips-of-an-Interview/</id>
    <published>2019-11-27T10:41:30.000Z</published>
    <updated>2019-11-27T10:59:00.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Attentive-Listening-in-an-Interview"><a href="#Attentive-Listening-in-an-Interview" class="headerlink" title="Attentive Listening in an Interview"></a>Attentive Listening in an Interview</h1><h2 id="1-Listen-for-hidden-questions"><a href="#1-Listen-for-hidden-questions" class="headerlink" title="1. Listen for hidden questions"></a>1. Listen for hidden questions</h2><h3 id="Interviewer-want-to-know-3-things"><a href="#Interviewer-want-to-know-3-things" class="headerlink" title="Interviewer want to know 3 things:"></a>Interviewer want to know 3 things:</h3><ol><li>CAN you do the job?</li><li>WILL you do the job?</li><li>Do you fit?</li></ol><h3 id="How-to-answer-these-questions"><a href="#How-to-answer-these-questions" class="headerlink" title="How to answer these questions?"></a>How to answer these questions?</h3><p>Use SAR model</p><ul><li>Situation</li><li>Action Taken</li><li>Result</li></ul><h2 id="2-Listen-to-what-the-interviewer-actually-saying"><a href="#2-Listen-to-what-the-interviewer-actually-saying" class="headerlink" title="2. Listen to what the interviewer actually saying"></a>2. Listen to what the interviewer actually saying</h2><ul><li>tone of voice</li><li>facial expression &amp; body language</li><li>place yourself in interveiewer’s position</li></ul><h2 id="3-Ask-for-more-information"><a href="#3-Ask-for-more-information" class="headerlink" title="3. Ask for more information"></a>3. Ask for more information</h2><ul><li>when you need additional information</li><li>rephrase the question</li><li>Interpret what you hear</li></ul><h2 id="4-Listen-to-get-the-interviewer’s-attention"><a href="#4-Listen-to-get-the-interviewer’s-attention" class="headerlink" title="4. Listen to get the interviewer’s attention"></a>4. Listen to get the interviewer’s attention</h2><p>Active listening will allow you </p><ul><li>SPOT on them</li><li>Capitalize on them</li></ul><h1 id="Common-interview-questions"><a href="#Common-interview-questions" class="headerlink" title="Common interview questions"></a>Common interview questions</h1><h2 id="Small-talk"><a href="#Small-talk" class="headerlink" title="Small talk"></a>Small talk</h2><p>you shall:</p><ul><li>be poilet and friendly</li><li>Keep your answers short</li><li>Feel free to turn the questions back to the interviewer</li><li>practice small talk on your own asking yourself simple, easy-to-answer, non-personal questions<h3 id="COMMON-QUESTION-1-Tell-me-a-little-bit-about-yourself"><a href="#COMMON-QUESTION-1-Tell-me-a-little-bit-about-yourself" class="headerlink" title="COMMON QUESTION 1: Tell me a little bit about yourself."></a>COMMON QUESTION 1: Tell me a little bit about yourself.</h3></li><li>Education and work history<h3 id="COMMON-QUESTION-2-Can-you-tell-me-how-you-heard-about-this-position"><a href="#COMMON-QUESTION-2-Can-you-tell-me-how-you-heard-about-this-position" class="headerlink" title="COMMON QUESTION 2: Can you tell me how you heard about this position?"></a>COMMON QUESTION 2: Can you tell me how you heard about this position?</h3></li><li>Share a little bit of reserch you have been done in order to learn the position that you are planning for.</li><li>Share if someone inside the company let you know the position<h3 id="COMMON-QUESTION-3-What-attracted-you-to-ur-company"><a href="#COMMON-QUESTION-3-What-attracted-you-to-ur-company" class="headerlink" title="COMMON QUESTION 3: What attracted you to ur company?"></a>COMMON QUESTION 3: What attracted you to ur company?</h3></li><li>Share what you learn about the company</li><li>Why you would like to work there<h3 id="COMMON-QUESTION-4-What-would-you-say-is-your-grestest-strengthen"><a href="#COMMON-QUESTION-4-What-would-you-say-is-your-grestest-strengthen" class="headerlink" title="COMMON QUESTION 4: What would you say is your grestest strengthen?"></a>COMMON QUESTION 4: What would you say is your grestest strengthen?</h3></li><li>Chance to share what you do really well as an employee and as a person</li><li>You can share what your greatest strengthen is, then explain how that helps you in your current job or life<h3 id="COMMON-QUESTION-5-Can-you-tell-me-about-a-time-when-you-suffered-a-setback-and-had-to-maintain-your-enthusiasm"><a href="#COMMON-QUESTION-5-Can-you-tell-me-about-a-time-when-you-suffered-a-setback-and-had-to-maintain-your-enthusiasm" class="headerlink" title="COMMON QUESTION 5: Can you tell me about a time when you suffered a setback and had to maintain your enthusiasm?"></a>COMMON QUESTION 5: Can you tell me about a time when you suffered a setback and had to maintain your enthusiasm?</h3></li><li>Know how you behave in a certain stress or situations<h3 id="COMMON-QUESTION-6-What-do-you-consider-to-be-your-greatest-weakness"><a href="#COMMON-QUESTION-6-What-do-you-consider-to-be-your-greatest-weakness" class="headerlink" title="COMMON QUESTION 6: What do you consider to be your greatest weakness?"></a>COMMON QUESTION 6: What do you consider to be your greatest weakness?</h3></li><li>To be honest</li><li>Share a weakness, like public speaking, or attention to detail, fear of failure.</li><li>Then talk about ways you’ve worked on improvement in that area.<h3 id="COMMON-QUESTION-7-Where-do-you-see-yourself-in-five-years"><a href="#COMMON-QUESTION-7-Where-do-you-see-yourself-in-five-years" class="headerlink" title="COMMON QUESTION 7: Where do you see yourself in five years?"></a>COMMON QUESTION 7: Where do you see yourself in five years?</h3></li><li>Chance to share your goals for the future.</li><li>You understand what is realistically achieveable over a certain period of time.</li><li>Let the interviewer know how ambitious you are with this answer.<h3 id="COMMON-QUESTION-8-Do-you-have-any-questions-for-me"><a href="#COMMON-QUESTION-8-Do-you-have-any-questions-for-me" class="headerlink" title="COMMON QUESTION 8: Do you have any questions for me?"></a>COMMON QUESTION 8: Do you have any questions for me?</h3></li><li>Find out if the company is a good fit for you.</li><li>The question you ask will also show how well you know ablut the company and the requirements of the position.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Attentive-Listening-in-an-Interview&quot;&gt;&lt;a href=&quot;#Attentive-Listening-in-an-Interview&quot; class=&quot;headerlink&quot; title=&quot;Attentive Listening in
      
    
    </summary>
    
    
      <category term="English" scheme="http://qidianxuan.github.io/categories/English/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-文法分析-上下文无关文法,文法和语言</title>
    <link href="http://qidianxuan.github.io/2019/11/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/"/>
    <id>http://qidianxuan.github.io/2019/11/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/</id>
    <published>2019-11-25T08:00:24.000Z</published>
    <updated>2019-11-29T10:52:12.820Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://qidianxuan.cn/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">词法分析</a>, 可以将一个字符串转换成记号流, 但是记号流如何转换成语法树, 需要进行语法分析.</p><ul><li>实质: 无结构的数据转化成有结构的数据</li><li>依据: 上下文无关语法</li></ul><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><ul><li>前言<ul><li>正规式来定义一些简单的语言，能表示给定结构的固定次数的重复或者没有指定次数的重复, 但</li><li>正规式不能用于描述配对或嵌套的结构</li></ul></li><li>定义<ul><li>上下文无关文法是四元组( $V_T,V_N,S,P$ )<ul><li>$V_T$: 终结符集合(非空有限集合)</li><li>$V_N$: 非终结符集合( $V_T \bigcap V_N = \emptyset$ )</li><li>S: 开始符号</li><li>P: 产生式集合 ( 产生式形式如$ A \rightarrow \alpha 其中 A \in V_N, \alpha \in (V_T \bigcup V_N)^*$ )</li></ul></li><li>例子<br>$ ( \{id,+, \ast ,-,(,) \} , \{expr,op\} , expr , P ) $<br>其中P包括:<br>expr $ \rightarrow $ expr op expr<br>expr $ \rightarrow $ (expr)<br>expr $ \rightarrow $ -expr<br>expr $ \rightarrow $ id<br>op $ \rightarrow $ +<br>op $ \rightarrow $ *  </li></ul></li><li>优点<ul><li>文法给出了精确的，易于理解的语法说明</li><li>自动产生高效的分析器</li><li>可以给语言定义出层次结构</li><li>以文法为基础的语言的实现便于语言的修改</li></ul></li><li><p>缺点</p><ul><li>文法只能描述编程语言的大部分语法</li></ul></li><li><p>文法推导</p><ul><li>推导: 把产生式看成重写规则，把符号串中的非终结符用其产生式右部的串来代替<br>以文法 $ E \rightarrow E+E|E \ast E|(E)|-E|id$为例:<br>存在代换序列: $ E \Rightarrow E+E \Rightarrow id+E \Rightarrow id+id $<br>这个代换序列即<strong>从E到id+id的推导</strong>,  </li><li>一般而言, 由上下无关文法产生的语言叫<strong>上下文无关语言</strong>  </li><li>若两个文法产生相同的语言, 则称这两个文法<strong>等价</strong>  </li><li>若存在S$\Rightarrow ^\ast \alpha$, 若α含非终结符, 则称其为文法的<strong>句型</strong>, 只含有终结符的句型, 称之为<strong>句子</strong>  </li><li>在推导过程中, 每一步都代换句型中最左边的非终结符的推导,称之为<strong>最左推导</strong>(写作$\alpha \Rightarrow _{lm}\beta$), 类似的,存在<strong>最右推导</strong>(写作$\alpha \Rightarrow _{rm}\beta$), 最右推导亦称为<strong>规范推导</strong></li></ul></li><li>分析树<ul><li>分析树即推导的图形表示.</li><li>例子:<br>以文法 $ E \rightarrow E+E|E \ast E|(E)|-E|id$为例:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/treeexam.jpg" alt="exm.png"><br>对于同样的句子, 其 <em>最终</em> 分析树是一样的, 但过程会有不同.</li></ul></li><li>二义性<ul><li>文法的二义性，是指对于符合文法规则的同一个句子，存在两种可能的分析树</li><li>考虑如下的情况:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/binexam.jpg" alt=""><br>对于同一个句子, 该句子存在二义性, 分析树存在了不同, 也带来了不同的释义, 左边的为 id*(id+id), 而右边为 (id*id)+id, 但对于句子id*id+id, 一般认为(id*id)+id是正确的</li><li>如何消除二义性, 一般而言, 需要加入<strong>消除二义性的规则</strong></li><li>以文法 $ E \rightarrow E+E|E \ast E|id$为例:<br>可以更改为如下规则:<br>$ E \rightarrow E + T | T $<br>$ E \rightarrow E \ast F | F $<br>$ F \rightarrow id | (E) $</li></ul></li><li>正规式可以描述的语言都可以用上下文无关文法来描述</li><li>NFA转化为上下文无关文法:<ol><li>确定终结符集合</li><li>为每个状态引入一个非终结符$A_i$</li><li>如果状态i有一个转换a到状态j, 则引入产生式$A_i \rightarrow aA_i $, 如果i是接收状态, 则引入$A_i \rightarrow \epsilon$<br>例子:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfa2lex.jpg" alt=""></li></ol></li><li>为什么要用正规式定义词法 <ul><li>词法规则非常简单,不必用上下文无关文法</li><li>对于词法记号,正规式描述简洁且易于理解</li><li>从正规式构造出的词法分析器效率高</li></ul></li><li>把词法分析从语法分析中分离出来的理由 <ul><li>简化设计</li><li>编译器的效率会改进</li><li>编译器的可移植性加强</li><li>便于编译器前端的模块划分</li></ul></li><li>能否把词法分析并入到语法分析中,直接从字符流进行语法分析?<ul><li>若把词法分析和语法分析合在一起，则必须将语言的注解和空白的规则反映在文法中，文法将大大复杂</li><li>注解和空白由自己来处理的分析器，比注解和空格已由词法分析器删除的分析器要复杂得多</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;https://qidianxuan.cn/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="http://qidianxuan.github.io/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://qidianxuan.github.io/2019/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2019-11-24T05:27:15.000Z</published>
    <updated>2019-12-08T08:29:13.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><ul><li>词法分析器: 把构成源程序的字符流翻译成记号(token)流，还完成和用户接口的一些任务<br>  其中:<ul><li>词法单元: 亦称单词, 编程语言中合法的字符串</li><li>词法记号: 满足某种给定规则(模式)的词法单元<br>示例: 对于词法记号NUM, 其词法单元可能有3.1, 10, 2.8E12等数字, 其”模式”即”认定为数字的字符串”</li></ul></li></ul><h2 id="串和语言"><a href="#串和语言" class="headerlink" title="串和语言"></a>串和语言</h2><ul><li>字母表: 符号的有限集合.   示例: Σ = {0,1}</li><li>串: 符号的有穷序列.       示例: 0110,ε(长度为0的空串)<br>运算:<ul><li>连接: xy, 其中sε = εs = s</li><li>积: $s^0 = \epsilon , s^i = s^{i-1}s(i&gt;0)$</li></ul></li><li>语言: 字母表上的一个串集. 示例: {ε, 0, 11, …}, {ε}, ∅<br>运算:<ul><li>和:$\sf L \bigcup M = \{s|s \in L 或 s \in M \}$</li><li>连接:$\sf LM = \{st|s \in L 且 s \in M\}$</li><li>指数:$\sf L^0=\{ε\}, L^i = L^{i-1}L$</li><li>闭包:$\sf L^* = L^0\bigcup L^1\bigcup L^2\bigcup …$</li><li>正闭包:$\sf L^+ = L^1 \bigcup L^2 \bigcup … 并且 L^* = L^0 \bigcup L^+$</li></ul></li></ul><h2 id="正规式-正则表达式"><a href="#正规式-正则表达式" class="headerlink" title="正规式(正则表达式)"></a>正规式(正则表达式)</h2><ul><li>正规式: 按照一定的定义规则, 由较简单的正规式构成, 每个正规式r表示一个<strong>语言</strong>L(r)</li><li>正规式是用于说明词法单元如何对应到词法记号的模式。与非形式化的描述相比，正规式更具形式化，更加精确</li><li>定义如下</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">定义的语言</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center">$\{\epsilon\}$</td><td style="text-align:center">以下定义均在字母表$\sum$中</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">{a}</td><td style="text-align:center">$a \in \sum$</td></tr><tr><td style="text-align:center">r   &#124;  s</td><td style="text-align:center">$\sf L(r) \bigcup L(s)$</td><td style="text-align:center">r和s为正规式</td></tr><tr><td style="text-align:center">rs</td><td style="text-align:center">L(r)L(s)</td><td style="text-align:center">L(r)L(s) = L(s)L(r)</td></tr><tr><td style="text-align:center">$\sf r^*$</td><td style="text-align:center">$\sf L(r)^*$</td><td style="text-align:center">r为正规式</td></tr></tbody></table></div><ul><li>运算符优先级: * &gt; 连接运算 &gt; |</li><li>举例</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">定义的语言</th></tr></thead><tbody><tr><td style="text-align:center">$\sf (a   &#124;  b)(a   &#124;  b)$</td><td style="text-align:center">{aa, ab, ba, bb}</td></tr><tr><td style="text-align:center">$\sf (a   &#124;  b)^*$</td><td style="text-align:center">由a和b构成的所有串集</td></tr></tbody></table></div><h2 id="词法记号的识别"><a href="#词法记号的识别" class="headerlink" title="词法记号的识别"></a>词法记号的识别</h2><ul><li>图形化:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">状态转换图</th></tr></thead><tbody><tr><td style="text-align:center">$\sf d \rightarrow a$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoa2.jpg" alt="dtoa.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoab.jpg" alt="dtoab.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a   &#124;  b$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoaorb.jpg" alt="dtoaorb.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a^*$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dtoap.jpg" alt="dtoap.jpg"></td></tr><tr><td style="text-align:center">$\sf d \rightarrow a?$(a出现1次或0次)</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/da.jpg" alt="da.jpg"></td></tr></tbody></table></div><ul><li>举例:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">状态转换图</th></tr></thead><tbody><tr><td style="text-align:center">$\sf d \rightarrow a(a &#124; b)^*$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/FAExample.jpg" alt="faexample.jpg"></td></tr></tbody></table></div><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><ul><li>识别器: 是一个程序，取串x作为输入，当x是语言的句子时，它回答“是”，否则回答“不是”</li><li>状态转换图即有限自动机, 可以作为识别器<h3 id="确定的有限自动机-DFA"><a href="#确定的有限自动机-DFA" class="headerlink" title="确定的有限自动机(DFA)"></a>确定的有限自动机(DFA)</h3></li><li>DFA是一个数学模型, 包括<ul><li>状态集合S</li><li>输入字母表$\sum$</li><li>转换函数$\sf move: S \times \sum \rightarrow S$</li><li>唯一的初态$\sf s \in S$</li><li>终态集合$\sf F \subseteq S$<h3 id="不确定的有限自动机-NFA"><a href="#不确定的有限自动机-NFA" class="headerlink" title="不确定的有限自动机(NFA)"></a>不确定的有限自动机(NFA)</h3></li></ul></li><li>NFA是一个数学模型, 包括<ul><li>状态集合S</li><li>输入字母表$\sf \sum$</li><li>转换函数$\sf move: S \times ( \sum \bigcup \{ \epsilon \})  \rightarrow S$(此处$\epsilon$理解为”未知”)</li><li>唯一的初态$\sf s \in S$</li><li>终态集合$\sf F \subseteq S$<h3 id="DFA与NFA的对比"><a href="#DFA与NFA的对比" class="headerlink" title="DFA与NFA的对比"></a>DFA与NFA的对比</h3></li></ul></li><li>举例:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">DFA</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$(a   &#124;  b)^*ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dfaexam.jpg" alt="dfae.jpg"></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfaexam.jpg" alt="nfae.jpg"></td></tr><tr><td style="text-align:center">状态转移表</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/dfachart.jpg" alt=""></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nfachart.jpg" alt=""></td></tr></tbody></table></div><ol><li>NFA中允许$\epsilon$转换边, 即允许$\epsilon$的输入, 而DFA不允许</li><li>NFA中的move(s,a)可能是个多元集合, 而DFA中的move(s,a)最多一个元素</li><li>DFA:<ul><li>优点: 快速定位</li><li>缺点: 字母表过大或大部分转换状态为空集时浪费空间</li></ul></li><li>NFA:<ul><li>优点: 表较小</li><li>缺点: 输入字符包括$\epsilon$, 一个状态对于某个字符，可能有多条输出边</li></ul></li><li>NFA更贴近于人们对正规式的认识</li><li>DFA因为每次状态转换都是确定性的<h3 id="DFA的构建"><a href="#DFA的构建" class="headerlink" title="DFA的构建"></a>DFA的构建</h3></li></ol><ul><li>由自然语言描述构建<br>方法:  <ol><li>列出所有可能的状态</li><li>从各个状态出发, 构造边及输入字符记号</li></ol></li><li>由正规式构建 </li><li>由正规式创建NFA再构建<ol><li>NFA构建<br>NFA创建, 有如下框架:</li></ol></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_e.jpg" alt="nf_e.jpg"></td></tr><tr><td style="text-align:center">a</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_a.jpg" alt="nf_a.jpg"></td></tr><tr><td style="text-align:center">s   &#124;  t</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_s_t.jpg" alt="nf_s_t.jpg"></td></tr><tr><td style="text-align:center">st</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_st.jpg" alt="nf_st.jpg"></td></tr><tr><td style="text-align:center">s*</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_sp.jpg" alt="nf_sp.jpg"></td></tr></tbody></table></div><p>对于加括号的正规式(s), 使用N(s)作为其NFA<br>    举例:</p><div class="table-container"><table><thead><tr><th style="text-align:center">正规式</th><th style="text-align:center">NFA</th></tr></thead><tbody><tr><td style="text-align:center">$\sf (a   &#124;  b)^{*}ab$</td><td style="text-align:center"><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_example.jpg" alt=""></td></tr></tbody></table></div><ol><li>NFA转化为DFA(子集构造法)<ul><li>有限自动机理论: 设L为一个有不确定的有限自动机接受的集合，则存在一个接受L的确定的有限自动机</li><li>DFA的一个状态是NFA的一个状态集合, 即对于一个输入$a_1a_2…a_n$NFA可以到达所有状态为:$s_1, s_2, …, s_k$, 这些状态的集合为DFA的一个状态</li><li>如上述的$(a|b)^*ab$其NFA为<img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_example.jpg" alt=""><br>则对于各种输入, 有如下集合:</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">集合名称</th><th style="text-align:center">输入</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">$\epsilon$</td><td style="text-align:center">{0,1,2,4,7}</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">$a$</td><td style="text-align:center">{1,2,3,4,6,7,8}</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">$b$</td><td style="text-align:center">{1,2,4,5,6,7}</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">$b, a, b$</td><td style="text-align:center">{1,2,4,5,6,7,9}</td></tr></tbody></table></div><p>依据上表列出状态转换表:<br>    <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_ex_chart.jpg" alt=""><br>再画出转换图:<br>    <img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_ex_p.jpg" alt=""></p><ol><li><p>DFA化简</p><ul><li><p>通常由上述方法得来的DFA并非最简的</p></li><li><p>状态的可区分性: 存在串w, 使得从状态s开始, 对w进行状态转换, 最终停在某个接受状态; 而对从t开始的状态转换停在了某个非接收状态<br><strong>简言之, 对于两个状态, 若其对于所有相同的输入转换后有相同的接受状态, 则其为不可区分的, 否则可区分 </strong><br>如上面的转换图 A与B可区分, A与C不可区分</p><ul><li>途径:<ul><li>根据状态是否可以区分，将状态划分成若干个集合，每个集合内的状态之间都不可区分，而任意两个集合中的元素都是可以互相区分的<ul><li>依据原始的DFA，在合并后的状态基础上，建立新的状态转换关系</li></ul></li></ul></li></ul></li><li><p>但是, 化简时DFA的状态转换函数必须是一个<strong>全函数</strong>(对于所有的输入都有对应的边，比如有a，b两个输入，那么每个状态必须有a，b两个出边，否则称之为部分函数)<br>部分函数需要添加<strong>死状态</strong>变成全函数，死状态即是添加一个状态，使所有缺失的边都指向它，它自己的所有输出边也指向本身，如下图<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/death.jpg" alt=""><br>加上了死状态E<br>但对于$\sf (a|b)^*ab$, 无需加死状态</p></li><li><p>化简$\sf (a|b)^*ab$<br>首先将接受状态和非接受状态分为两个部分<br>{A, B, C}, {D}<br>对于非接受状态，判断其转换函数<br>move({A, B, C}, a} = {B}结果还是非接受状态<br>move({A, B, C}, b} = {C, D}结果出现接受状态，而这种    改变是由于状态B造成，因此将B拆分出来<br>{A, C}, {B}, {D}<br>再重复以上过程<br>move({A, C}, a} = {B}<br>move({A, C}, b} = {C}<br>发现A，C不存在例外了<br>为格式化，我们将字母变成数字表示，将A,C合并<br>其中0代表A, C, 1代表B, 2代表D  </p></li><li>最终:<br><img src="https://raw.githubusercontent.com/InnocentYoume/PicBed/master/img/nf_fin.jpg" alt=""></li></ul></li></ol><h4 id="至此-词法分析完成"><a href="#至此-词法分析完成" class="headerlink" title="至此, 词法分析完成!"></a>至此, 词法分析完成!</h4><p>参考链接:</p><p> <a href="https://blog.csdn.net/zp_icenow/article/details/82661407" target="_blank" rel="noopener">https://blog.csdn.net/zp_icenow/article/details/82661407</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;词法分析器&quot;&gt;&lt;a href=&quot;#词法分析器&quot; class=&quot;headerlink&quot; title=&quot;词法分析器&quot;&gt;&lt;/a&gt;词法分析器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;词法分析器: 把构成源程序的字符流翻译成记号(token)流，还完成和用户接口的一些任务&lt;br&gt;  其中
      
    
    </summary>
    
    
      <category term="编译原理" scheme="http://qidianxuan.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>How to Write An E-Mail</title>
    <link href="http://qidianxuan.github.io/2019/11/23/HowtoWriteAnE-Mail/"/>
    <id>http://qidianxuan.github.io/2019/11/23/HowtoWriteAnE-Mail/</id>
    <published>2019-11-23T07:09:39.000Z</published>
    <updated>2019-11-27T10:43:05.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Writing-an-Email-you-should"><a href="#Writing-an-Email-you-should" class="headerlink" title="Writing an Email you should:"></a>Writing an Email you should:</h1><ol><li>Use a Neutral Email Address</li><li>Use a short and accurate subject header</li><li>Use a proper salutation (formal)<ul><li>Title + Last name</li><li>Commonly used titles: ‘Mr.’ ,’Mrs.’,’Miss.’ …</li></ul></li><li>Introduce yourself in the First Paragraph if necessary (formal)</li><li>Write the actual message<ul><li>Do not indent</li><li>Insert a line break</li><li>No more than 5 paragraphs and No more than 5 sentences in each paragraph</li></ul></li><li>Use the correct form of leaving-taking</li><li>Sign properly</li><li>Proofread(校对) your email</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Writing-an-Email-you-should&quot;&gt;&lt;a href=&quot;#Writing-an-Email-you-should&quot; class=&quot;headerlink&quot; title=&quot;Writing an Email you should:&quot;&gt;&lt;/a&gt;Writ
      
    
    </summary>
    
    
      <category term="English" scheme="http://qidianxuan.github.io/categories/English/"/>
    
    
  </entry>
  
  <entry>
    <title>网络综合实验常用指令汇总</title>
    <link href="http://qidianxuan.github.io/2019/11/22/NetCmds/"/>
    <id>http://qidianxuan.github.io/2019/11/22/NetCmds/</id>
    <published>2019-11-22T09:50:02.000Z</published>
    <updated>2019-11-23T07:00:47.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>模拟器 : HCL</li><li>路由器 : MSR36-20</li><li>交换机 : S5820V2-54QS-GE</li><li>操作系统 : ComwareV7.0<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><h3 id="TELNET方式登录交换机"><a href="#TELNET方式登录交换机" class="headerlink" title="TELNET方式登录交换机"></a>TELNET方式登录交换机</h3>使用如下命令:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[SW]int vlan &#123;vlanid&#125;</span><br><span class="line">[SW-Vlan-interface1]ip address &#123;IP地址&#125; &#123;子网掩码&#125;</span><br><span class="line">[SW-Vlan-interface1]telnet server enable</span><br><span class="line">[SW]user-interface vty 0 4</span><br><span class="line">[SW-line-vty0-4]auth password</span><br><span class="line">[SW-line-vty0-4]set auth pass simple &#123;密码&#125;</span><br><span class="line">[SW-line-vty0-4]user level-3</span><br></pre></td></tr></table></figure>如上,之后在PC使用如下指令即可:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &#123;之前设置的ip地址&#125;</span><br></pre></td></tr></table></figure>如果使用交换机,记得设置交换机ip地址</li></ul><h3 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h3><p>首先,要新建立一个聚合组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SW]interface bridge-aggregation &#123;聚合端口号 0-1024&#125;</span><br></pre></td></tr></table></figure><br><br>注意 : 同一个聚合下的端口必须都工作在全双工模式下且速率相同<br><br>配置端口模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW-GigabitEthernet1/0/1]duplex &#123;工作模式: fall|half|auto&#125;</span><br><span class="line">[SW-GigabitEthernet1/0/1]speed &#123;速率: 10|100|1000|auto&#125;</span><br></pre></td></tr></table></figure><br>加入一个端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]interface Ethernet &#123;端口号,以1/0/1为例&#125;</span><br><span class="line">[SW-GigabitEthernet1/0/1]port link-aggregation &#123;聚合端口号&#125;</span><br></pre></td></tr></table></figure><br>如上,端口 1/0/1 被 聚合 到 组2 内,之后,可以看一下结果<br><br>显示聚合信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SW]display link-aggregation summary</span><br></pre></td></tr></table></figure></p><h3 id="生成树协议配置"><a href="#生成树协议配置" class="headerlink" title="生成树协议配置"></a>生成树协议配置</h3><p>首先,为了使各交换机使用相同的生成树协议标准,先在个交换机执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]stp mode rstp</span><br><span class="line">[SW]stp patchcost-standard legacy</span><br></pre></td></tr></table></figure><br>因为STP默认开启,所以此时STP已打开</p><h3 id="VLAN配置"><a href="#VLAN配置" class="headerlink" title="VLAN配置"></a>VLAN配置</h3><p>创建vlan将端口加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW]vlan &#123;vlan id&#125;</span><br><span class="line">[SW-vlan2]prot GigabitEthernet &#123;起始端口号&#125; to &#123;终止端口号&#125;</span><br></pre></td></tr></table></figure><br>注意 : 也可以只写一个port来加入,这样创建的port类型为缺省值access port<br>要建立trunk port,需要首先对目标端口进行链路聚合(哪怕只有一个端口)<br>之后,进行如下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SW-bridge-aggregation1]port link-type trunk</span><br><span class="line">[SW-bridge-aggregation1]port trunk permit vlan &#123;源Vlan id&#125; to &#123;目标vlan id&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="使用TELNET登录路由器"><a href="#使用TELNET登录路由器" class="headerlink" title="使用TELNET登录路由器"></a>使用TELNET登录路由器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RT]telnet server enable  /缺省情况下，Telnet服务处于关闭状态</span><br><span class="line">[RT]line vty 0   /进入一个或多个VTY用户线视图</span><br><span class="line">[RT-line-vty0]authentication-mode scheme  /设置登录用户的认证方式为通过AAA认证</span><br><span class="line">[RT]local-user test class manage（创建用户名）</span><br><span class="line">[RT-luser-manage-test]password simple &#123;密码&#125;</span><br><span class="line">[RT-luser-manage-test]service-type telnet</span><br><span class="line">[RT-luser-manage-test]authorization-attribute user-role network-admin（设置登陆权限是超级用户最高权限）</span><br></pre></td></tr></table></figure><h3 id="路由协议设置"><a href="#路由协议设置" class="headerlink" title="路由协议设置"></a>路由协议设置</h3><p>静态路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static &#123;dest ip addr&#125; &#123;mask&#125; &#123;next-hoop&#125;</span><br></pre></td></tr></table></figure><br>显示路由表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsiplay ip routing-table</span><br></pre></td></tr></table></figure><br>rip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[RT]rip</span><br><span class="line">[RT-rip1]network &#123;指定网段地址&#125; &#123;反子网掩码&#125;</span><br></pre></td></tr></table></figure><br>注意:需要添加所有需要的网段地址,包括自己</p><p><br><br>ospf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]ospf</span><br><span class="line">[RT-ospf-1]area 0</span><br><span class="line">[RT-ospf-1-area-0.0.0.0]network &#123;要启用的ip&#125; &#123;反子网掩码&#125;</span><br></pre></td></tr></table></figure><h3 id="广域网协议设置"><a href="#广域网协议设置" class="headerlink" title="广域网协议设置"></a>广域网协议设置</h3><h4 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h4><p><br>pap为双向认证,需要双方都开启<br><br><br><br>验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp authentication-mode pap</span><br><span class="line">[RA]local-user &#123;用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure><br>被验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RB-Serial1/0]ppp pap local-user &#123;用户名&#125; password simple &#123;密码&#125;</span><br></pre></td></tr></table></figure><br>注意:此处用户名与密码须与上述相同<br><br>此时只实现了单向验证,双方是无法ping通的,需要实现双向认证</p><h4 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h4><p><br>验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp authentication-mode chap</span><br><span class="line">[RA-Serial1/0]ppp chap user &#123;对方用户名&#125;</span><br><span class="line">[RA]local-user &#123;自己用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure><br>被验证方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RA-Serial1/0]ppp chap user &#123;对方用户名&#125;</span><br><span class="line">[RA]local-user &#123;自己用户名&#125;</span><br><span class="line">[RA-luser-manage-ra]service-type ppp</span><br><span class="line">[RA-luser-manage-ra]password simple &#123;密码&#125;</span><br><span class="line">[RA-Serial1/0]shutdown</span><br><span class="line">[RA-Serial1/0]undo shutdwon</span><br></pre></td></tr></table></figure></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>基于basic ACL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]acl basic &#123;acl编号2000~&#125; match-order auto</span><br><span class="line">[RT-acl-inv4-adv-2001]rule &#123;permit|deny&#125; ip &#123;source|dest&#125; &#123;反子网掩码&#125;</span><br><span class="line">[RT-Eth/Ser]packet-filter 2001 &#123;inbound|outbound&#125;</span><br></pre></td></tr></table></figure><br>基于advanced ACL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT]acl advanced &#123;acl编号3000~&#125; match-order auto</span><br><span class="line">[RT-acl-inv4-adv-3001]rule &#123;permit|deny&#125; ip source &#123;源ip地址|any&#125; &#123;反掩码|前为any时不写&#125; destination &#123;目的ip地址|any&#125; &#123;反掩码|前为any时不写&#125;</span><br><span class="line">[RT-Eth/Ser] packet-filter 3001 &#123;inbound|outbound&#125;</span><br></pre></td></tr></table></figure></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>首先要建立地址池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[RT]nat address-group &#123;id&#125; </span><br><span class="line">[RT-address-group-1]address &#123;被映射ip组&#125; &#123;目标映射IP组&#125;</span><br></pre></td></tr></table></figure><br>同时要建立acl,如防火墙<br><br>最后,应用在端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RT-Serial1/0]nat outbound &#123;acl id&#125; address-group &#123;group id&#125;</span><br></pre></td></tr></table></figure><br>另外,对于具体到某个端口的nat映射,有如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RT-Serial1/0]nat server protocol tcp global &#123;映射ip&#125; &#123;映射端口号&#125; inside &#123;被映射的ip&#125; &#123;被映射端口号&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验设备&quot;&gt;&lt;a href=&quot;#实验设备&quot; class=&quot;headerlink&quot; title=&quot;实验设备&quot;&gt;&lt;/a&gt;实验设备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;模拟器 : HCL&lt;/li&gt;
&lt;li&gt;路由器 : MSR36-20&lt;/li&gt;
&lt;li&gt;交换机 : S5820V2
      
    
    </summary>
    
    
      <category term="网络" scheme="http://qidianxuan.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
